<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no" />
    <title>Start Screen</title>


        <div class="loader-container" id="loaderContainer">
        <div>
            <div class="loader">
                <div class="progress" id="progressBar"></div>
            </div>
            <div class="percentage" id="percentageText">0%</div>
        </div>
    </div>

    <script
      data-hcs-config=""
      data-hcs-cdn-url="https://kiloscribe.com/api/inscription-cdn/"
      data-hcs-network="mainnet"
      data-hcs-debug="true"
      data-hcs-retry-attempts="5"
      data-hcs-retry-backoff="500"
      data-hcs-show-loading-indicator="true"
      data-hcs-loading-callback-name="setLoadingIndicator"
      type="e5a3c1b79eab779120034ec1-text/javascript"
    ></script>



<    <link
data-src="hcs://1/0.0.8287094"
data-script-id="map css"
    />

    <script
    data-src="hcs://1/0.0.8269272"
    data-script-id="maplibre"
    ></script>
    
    <script
    data-src="hcs://1/0.0.8269285"
    data-script-id="supercluster"
  ></script>

  <script
  data-src="hcs://1/0.0.8355670"
  data-script-id="threejs 137 + GLTFLoader"
></script>

<script
data-src="hcs://1/0.0.9196067"
data-script-id="walletconnect"
></script>

<script
data-src="hcs://1/0.0.9678314"
data-script-id="DRACOLoader"
></script>

<script
data-src="hcs://1/0.0.9705945"
data-script-id="dracoBase64"
></script>


    <style>
      
      html, body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        position: fixed;
      }

      .maplibregl-canvas {
        background-color: rgb(0, 0, 0) !important;
      }

      #map {
        position: fixed;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
        width: 100%;
        height: 100%;
      }

      #three-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
      }

      .toolbar {
        position: fixed;
        display: flex;
        flex-direction: column;
        background-color: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 1vh 1vw;
        border-radius: 1vh;
        z-index: 1001;
        justify-content: space-around;
        top: 10vh;
        left: 0;
        transform: none;
      }

      .toolbar-containers {
        background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 1vh 1vw; 
            border-radius: 4px; 
            box-sizing: border-box; 
            border-radius: 1vh;      
            overflow-y: auto; /* Enable vertical scrolling */
            max-height: 80vh; /* Limit the height to 80% of the viewport */
            touch-action: auto; /* Enable touch interactions */
            width: 73.5vw;
            padding-right: 2vw;
            resize: none; /* Prevent manual resizing */
      }

      .topic-chat-container {
        background-color: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 1vh 1vw; 
            border-radius: 4px; 
            box-sizing: border-box; 
            border-radius: 1vh;      
            overflow-y: auto; /* Enable vertical scrolling */
            max-height: 80vh; /* Limit the height to 80% of the viewport */
            touch-action: auto; /* Enable touch interactions */
            width: 73.5vw;
            padding-right: 2vw;
            resize: none; /* Prevent manual resizing */
      }


      .toolbar-column {
        display: block;
          width: 100% !important;
          color: white;
          padding-left: 1vw;
          border: 0.1vh solid white;
          border-radius: 1vh;
          font-size: 2vh;
          box-sizing: border-box;
          margin-bottom: 0.5vh;
          height: 5vh;
          border: 0.1vh solid rgb(0, 123, 255);
          overflow: hidden; /* Hide scrollbars */
          resize: none; /* Prevent manual resizing */
          background-color: transparent;
          touch-action: auto; /* Enable touch interactions */

      }

      .toolbar-group {
          width: 100% !important;
          color: white;
          padding-top: 1vh;
          padding-bottom: 0vh !important;
          padding-left: 1vw;
          padding-right: 1vw;
          border: 0.1vh solid white;
          border-radius: 1vh;
          box-sizing: border-box;
          margin-bottom: 0.5vh;
          border: 0.1vh solid #ffc107;
          overflow: hidden; /* Hide scrollbars */
          resize: none; /* Prevent manual resizing */
          background-color: transparent;
          touch-action: auto; /* Enable touch interactions */

      }

      .toolbar-column-btns {
        display: block;
          width: 100% !important;
          color: white !important;
          padding: 1vh 1vw;
          border: 0.1vh solid white;
          border-radius: 1vh;
          font-size: 2vh;
          box-sizing: border-box;
          margin-bottom: 0.5vh;
          height: 5vh;
          background-color: transparent;
          border: 0.1vh solid rgb(0, 123, 255);
      }

      .toolbar-column-btns:hover,
      .toolbar-column-btns:active {
        background-color: rgb(0, 123, 255) !important;
        color: white !important;
      }

      .toolbar-column:hover,
      .toolbar-column.active {
        background-color: rgba(255, 255, 255, 0.2);
      }
      .flex-container {
        display: flex;
        align-items: center;
        margin-bottom: 1.33vh;
        position: relative;
        z-index: 003;
      }
      #wallet-section {
        position: fixed;
        top: 0;
        left: 0;
        display: flex;
        flex-direction: column; /* Stack items vertically */
        align-items: flex-start;
        font-size: 1.6vw;
        border-radius: 1.07vw;
        background-color: rgba(51, 51, 51, 0.0);
        z-index: 5003;
        backdrop-filter: blur(5px);
      }

      #connect-wallet-btn {
        background-color: #007bff;
        color: white;
        border: none;
        padding: 0.8vh 1vw;
        border-radius: 0.8vh;
        cursor: pointer;
        font-size: 1.5vh;
        text-shadow: 0 0 0.5vh black;
        margin-top: 0.3vh;
        margin-left: 0.3vh;
      }
      #disconnect-wallet-btn {
        display: none;
        background-color: #ffc107;
        color: white;
        border: none;
        padding: 0.8vh 1vw;
        border-radius: 0.8vh;
        cursor: pointer;
        font-size: 1.5vh;
        text-shadow: 0 0 0.5vh black;
        margin-top: 0.3vh;
        margin-left: 0.3vh;
      }
      .account-info {
        display: flex;
        flex-direction: column;
        font-family: Arial, sans-serif;
        color: white;
        padding-top: 0.5vh;
        border: none;
        border-radius: 0.8vh;
        cursor: pointer;
        font-size: 1.5vh;
      }
      #account-id {
        color: white;
      }

      #coordinates-display {
        position: fixed; 
        right: 0; 
        background-color: rgba(0, 0, 0, 0.7); 
        color: white; 
        padding: 5px 10px; 
        border-radius: 4px; 
        font-family: Arial, sans-serif; 
        z-index: 1000; 
        top: 0; 
        font-size: 2vh; 
        border: none; 
        width: auto;
        pointer-events: none; /* Allow clicks to pass through */
      }

      #speed-slider {
        position: absolute;
        top: 3vh;
        right: 0;
        z-index: 1005;
        width: 32.5vw;
        height: 3vh;
        writing-mode: bt-lr;
        transform: rotate(0deg);
      }
      
      .touch-button {
        background-color: rgba(0, 0, 0, 0.2);
        color: white;
        border: 2px solid white;
        padding: 0.5vh;
        margin: 0.3vh;
        border-radius: 1vh;
        cursor: pointer;
        font-size: 2vh;
        width: 6vh;
        height: 6vh;
        display: flex;
        align-items: center;
        justify-content: center;
        backdrop-filter: blur(2px);
      }

      .touch-button:hover {
        background-color: rgba(255, 255, 255, 0.2);
        border-color: rgba(255, 255, 255, 0.8);
      }
      .button-container {
        display: grid;
        position: fixed;
        bottom: 5vh;
        z-index: 1004;
        grid-template-columns: repeat(3, 6vh);
        grid-template-rows: repeat(3, 6vh);
        gap: 0.3vh;
        justify-items: center;
        align-items: center;
      }

      #left-dpad {
        left: 0.5vw;
      }

      #right-dpad {
        right: 0.5vw;
      }

      #left-dpad,
      #right-dpad {
        display: none;
      }

      #zoom-controls {
        position: fixed;
        bottom: 40vh;
        right: 0.5vw;
        z-index: 1005;
        display: none;
        flex-direction: column;
        gap: 0.5vh;
      }

      .zoom-button {
        background-color: rgba(0, 0, 0, 0.2);
        color: white;
        border: 2px solid white;
        width: 8vh;
        height: 8vh;
        margin: 0.3vh;
        border-radius: 50%;
        cursor: pointer;
        font-size: 2.5vh;
        display: flex;
        align-items: center;
        justify-content: center;
        backdrop-filter: blur(2px);
      }

      .zoom-button:hover {
        background-color: rgba(255, 255, 255, 0.2);
        border-color: rgba(255, 255, 255, 0.8);
      }

      #toggle-controls-btn {
        position: fixed;
        top: 6.5vh;
        left: 0;
        z-index: 1006;
        background-color: #007bff;
        color: white;
        border: none;
        padding: 0.8vh 1vw;
        border-radius: 0.8vh;
        cursor: pointer;
        font-size: 1.5vh;
        display: none;
      }



      .maplibregl-popup {
        max-width: none;
        font: 2vh/3vh 'Helvetica Neue', Arial, Helvetica, sans-serif;
        text-align: left;
      }

      .maplibregl-popup-content {
  background-color: rgba(0, 0, 0, 0.8);
  color: white;
  padding: 1vh;
  border-radius: 1vh;
  font-size: 2vh;
  box-shadow: 0 1vh 2vh rgba(0, 0, 0, 0.3);
  text-align: left;
  word-wrap: break-word;
  white-space: normal;
  max-width: 50vw;
  width: max-content;
  border: 0.3vh solid white;
  user-select: text !important; /* Allow text selection in popups */
  -webkit-user-select: text !important; /* Safari */
  -moz-user-select: text !important; /* Firefox */
  -ms-user-select: text !important; /* IE/Edge */
  transform: translate(-50%, -3.5%); /* Center both horizontally and vertically */
  position: absolute; /* Ensure proper positioning */
}

      .maplibregl-popup-content * {
        user-select: text !important; /* Allow text selection for all child elements */
        -webkit-user-select: text !important;
        -moz-user-select: text !important;
        -ms-user-select: text !important;
      }

      .maplibregl-popup-close-button {
        color: white;
        font-size: 3vh;
        border: none;
        background: none;
        box-shadow: none;
        padding: 0;
        margin: 0;
        outline: none;
        position: absolute;
        top: -1vh;
        right: 0;
      }

      .maplibregl-popup-tip {
        border: none;
        width: 0;
        height: 0;
        border-left: 1vh solid transparent;
        border-right: 1vh solid transparent;
        border-top: 1vh solid rgba(0, 0, 0, 0.8);
        margin: 0 auto;
      }

      .maplibregl-popup-anchor-bottom .maplibregl-popup-tip {
        border-top-color: rgba(0, 0, 0, 0.8);
        border-bottom-color: transparent;
      }


      * {
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -khtml-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        touch-action: none;
      }

      input, textarea {
        -webkit-user-select: text;
        -khtml-user-select: text;
        -moz-user-select: text;
        -ms-user-select: text;
        user-select: text;
        touch-action: manipulation;
      }

      button[type="submit"],
      #submit-button,
      #submit-button-column2,
      #submit-button-column3,
      #submit-button-column5,
      #submit-button-change-memo,
      #submit-button-set-rules,
      #add-topic-id,
      #remove-topic-id {
        height: 5vh; /* Adjust the height as needed */
        font-size: 2vh; /* Adjust the font size for better readability */
        border-radius: 1vh; /* Add this line to make the buttons round */
      }

      #crosshair {
        display: none; /* Add this line to hide by default */
        position: fixed;
        top: 50%;
        left: 50%;
        width: 2px;
        height: 2px;
        background-color: white;
        transform: translate(-50%, -50%);
        z-index: 1007;
      }
      #crosshair::before {
        content: '';
        position: absolute;
        background-color: var(--crosshair-color, rgb(250, 4, 4)); /* Default color if variable is not set */
        width: var(--crosshair-before-width, 20px); /* Width of the crosshair line */
        height: var(--crosshair-before-height, 2px); /* Default thickness */
        top: 50%; /* Center vertically */
        left: 50%; /* Center horizontally */
        transform: translate(-50%, -50%); /* Adjust to center */
      }
      #crosshair::after {
        content: '';
        position: absolute;
        background-color: var(--crosshair-color, rgb(250, 4, 4)); /* Default color if variable is not set */
        width: var(--crosshair-after-width, 2px); /* Width of the crosshair line */
        height: var(--crosshair-after-height, 20px); /* Height of the crosshair line */
        top: 50%; /* Center vertically */
        left: 50%; /* Center horizontally */
        transform: translate(-50%, -50%); /* Adjust to center */
      }

      .popup-welcome-msg {
  position: fixed;
  top: 27.5vh; /* Use vh for vertical positioning */
  left: 50vw; /* Use vw for horizontal positioning */
  transform: translate(-50%, -50%);
  background-color: white;
  border: 0.5vh solid #ccc; /* Use vh for border thickness */
  padding: 0.1em; /* Use em for padding */
  z-index: 1003;
  box-shadow: 0 0 1vh rgba(0, 0, 0, 0.1); /* Use vh for shadow */
  border-radius: 3em; /* Use em for border radius */
  width: 80vw; /* Increase width */
  max-width: 90vw; /* Ensure it doesn't exceed viewport width */
  height: auto; /* Allow height to adjust based on content */
  max-height: 60vh; /* Limit the height to ensure it fits on screen */
  line-height: 1.5em; /* Improve line spacing */
}

.popup-content-welcome {
  text-align: center;
  border-radius: 1em; /* Use em for border radius */
  font-size: 2em; /* Base font size */
  line-height: 1em;

}

#close-welcome-msg {
  margin-top: 1em; /* Use em for margin */
  padding: 0.5em 1em; /* Use em for padding */
  background-color: #007bff;
  color: white;
  border: none;
  border-radius: 1em; /* Use em for border radius */
  cursor: pointer;
  font-size: 1em; /* Use em for button font size */
}

@media (min-aspect-ratio: 11/10) {
  .popup-welcome-msg {
    padding: 2vh; /* Use vh for padding */
    font-size: 3vh; /* Use vh for font size */
    line-height: 1.5vh; /* Use vh for line spacing */
    top: 40vh;
    width: 40vw;
  }

  .popup-content-welcome {
    border-radius: 1vh; /* Use vh for border radius */
    font-size: 3vh; /* Use vh for button font size */

  }

  #close-welcome-msg {
    margin-top: 1vh; /* Use vh for margin */
    padding: 0.5vh 1vh; /* Use vh for padding */
    border-radius: 1vh; /* Use vh for border radius */
    font-size: 3vh; /* Use vh for button font size */
  }

}

.loader-container {
            text-align: center;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 6000;
        }
        .loader {
            width: 200px;
            height: 20px;
            background-color: #e0e0e0;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
            margin-top: 50vh;
        }
        .progress {
            width: 0%;
            height: 100%;
            background-color: #4CAF50;
            transition: width 0.3s ease;
        }
        .percentage {
            margin-top: 10px;
            font-size: 24px;
            font-weight: bold;
            color: #333;
        }
        .hidden {
            display: none;
        }

    </style>
  </head>

  <body>
    <div id="map"></div>
    <div id="three-container"></div>
    <input id="coordinates-display" value="Coordinates:"/>
<button id="copy-coordinates" style="
position: fixed;
right: 0;
top: 0;
width: 30vw; /* Match the width of the coordinates display */
height: 3vw; /* Match the height of the coordinates display */
z-index: 1001; /* Ensure the button is above the input field */
background-color: transparent; /* Make the button invisible */
border: none;
cursor: pointer;
font-size: 1.5vh;
"></button>

    <div id="toolbar" class="toolbar" style="display: none; flex-direction: column; width: 25vw; ">

      <div class="toolbar-column" id="edit-profile">Edit</div>
      <div class="toolbar-column" id="column1">Load</div>
      <div class="toolbar-column" id="column5">Create</div>
      <div class="toolbar-column" id="column2">Marker</div>
      <div class="toolbar-column" id="column3">Polygon</div>
      <div class="toolbar-column" id="set-rules">Set Rules</div>
      <div class="toolbar-column" id="change-memo">Update Topic</div>
      <div class="toolbar-column" id="stack-topic-ids-column">Stack topic IDs</div>

    </div>

    <div id="edit-profile-column" style="display: none; position: absolute; z-index: 1002;">
      <div id="edit-profile-column-container"
      class="toolbar-containers"
      onclick="event.stopPropagation();"
      >
    <textarea 
    type="text" 
    id="toolbar-input"
    placeholder="URL/name/domain"
    class="toolbar-column"
    onclick="event.stopPropagation();"
    style="background-color: transparent;"
    oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
  ></textarea>
  <label for="change-profile" style="font-size: 2vh; padding-bottom: 0.5vh;">CHANGE:</label>
  <div style="display: flex; flex-direction: row; width: 100%;">
  <button class="toolbar-column-btns" id="button1" style="display: block; width: 20vw;">Profile pic</button>
  <label for="change-profile" style="font-size: 2vh; padding-bottom: 0.5vh; text-align: center; margin-left: 4vw; margin-right: 4vw; padding-top: 1.5vh;">OR</label>
  <button class="toolbar-column-btns" id="button2" style="display: block; width: 20vw;">Username</button>
</div>
  <textarea 
  type="text" 
  id="edit-profile-topic-id"
  placeholder="Topic ID"
  class="toolbar-column"
  style="background-color: transparent;"
  onclick="event.stopPropagation();"
  oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
></textarea>
<button class="toolbar-column-btns" id="button3">Change topic ID name</button>
<textarea 
type="text" 
id="domain-time-left"
placeholder="Domain time left"
class="toolbar-column"
style="        background-color: transparent;
overflow: hidden; /* Hide scrollbars */
resize: none; /* Prevent manual resizing */
"
onclick="event.stopPropagation();"
readonly
></textarea>
<button class="toolbar-column-btns" id="button4">Check domain availability</button>

<label for="domain-time-left" style="font-size: 2vh; padding-bottom: 0.5vh;">1 USDC (0.0.456858):</label>
<button class="toolbar-column-btns" id="button5">Add 28 days to domain</button>
</div>
</div>

    <div id="load-column" style="display: none; position: absolute; z-index: 1002;">
      <div
        id="load-column-container"
        class="toolbar-containers"
        onclick="event.stopPropagation();"
        >
        <textarea
          class="toolbar-column"
          type="text"
          id="input-field"
          placeholder="Domain/Topic ID"
          onclick="event.stopPropagation();"
          style="background-color: transparent;"
          oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
        ></textarea>
        <button id="submit-button" class="toolbar-column-btns">Load Data</button>
        <label for="loaded-topics" style=" font-size: 2vh;padding: 0px;">Loaded Topics with names not domains:</label>
        <textarea
        class="toolbar-column"
        type="text"
        id="loaded-topics"
        placeholder="Loaded Topics"
        onclick="event.stopPropagation();"
        style="background-color: transparent;"
        readonly
      ></textarea>
      <textarea
      class="toolbar-column"
      type="text"
      id="load-msgs-from-ids"
      placeholder="user ID or IDs separated by comma"
      onclick="event.stopPropagation();"
      style="background-color: transparent;"
      oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
    ></textarea>
    <button id="load-msgs-from-ids-button" class="toolbar-column-btns">Load Messages From</button>
      </div>
    </div>

    <div
    id="create-column"
    style="display: none; position: absolute; z-index: 1002;"
  >
    <div id="create-column-container" class="toolbar-containers"
    onclick="event.stopPropagation();"
    >
    <div class="toolbar-group">
  <textarea
  class="toolbar-column"
  type="text"
  id="input-field-5-1"
  placeholder="Admins 0.0.1,0.0.2.."
  style="
    background-color: transparent;
    overflow: hidden; /* Hide scrollbars */
    resize: none; /* Prevent manual resizing */
  "
  onclick="event.stopPropagation();"
  oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
></textarea>
    <textarea
    class="toolbar-column"
    type="text"
    id="input-field-5-2"
    placeholder="Use publickey here"
    style="
    background-color: transparent;
    overflow: hidden; /* Hide scrollbars */
    resize: none; /* Prevent manual resizing */
  "
          onclick="event.stopPropagation();"
          oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
          ></textarea>
          <label for="public-key-label"style="font-size: 2vh; padding: 0px; user-select: text;">If it doesnt load go to hashscan.io or app.dragonglass.me and input your acc id:</label>

  <input
  class="toolbar-column"
  type="text"
  id="input-field-5"
  placeholder="Generated Topic ID"
  style="
    background-color: transparent;
    overflow: hidden; /* Hide scrollbars */
    resize: none; /* Prevent manual resizing */
  "
onclick="event.stopPropagation();"
readonly
/>

<!-- <label for="public-key-label"style="font-size: 2vh; padding: 0px;">Set fee for each message:</label>
<textarea
class="toolbar-column"
type="text"
id="input-field-5-3"
placeholder="Set amount of fee"
style="
  background-color: transparent;
  overflow: hidden; /* Hide scrollbars */
  resize: none; /* Prevent manual resizing */
"
onclick="event.stopPropagation();"
oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
></textarea>
<textarea
class="toolbar-column"
type="text"
id="input-field-5-4"
placeholder="Set token id of fee"
style="
  background-color: transparent;
  overflow: hidden; /* Hide scrollbars */
  resize: none; /* Prevent manual resizing */
"
onclick="event.stopPropagation();"
oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
></textarea>
<textarea
class="toolbar-column"
type="text"
id="input-field-5-5"
placeholder="Set royalty account"
style="
  background-color: transparent;
  overflow: hidden; /* Hide scrollbars */
  resize: none; /* Prevent manual resizing */
"
onclick="event.stopPropagation();"
oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
></textarea> -->

    <button id="submit-button-column5" class="toolbar-column-btns" style="color: black; display: block; width: 48vw">Create</button>
  </div>
  <div class="toolbar-group">
    <label for="public-key-label"style="font-size: 2vh; padding: 0px;">Public Key:</label>
    <textarea
    class="toolbar-column"
    id="generated-public-key"
    placeholder="Generated Public Key"
    style="
    background-color: transparent;
    overflow: hidden; /* Hide scrollbars */
    resize: none; /* Prevent manual resizing */
  "
    readonly
    onclick="event.stopPropagation();"
  ></textarea>

  <label for="private-key-label"style="font-size: 2vh; padding: 0px;">Private Key:</label>
  <textarea
    class="toolbar-column"
    id="generated-private-key"
    placeholder="Generated Private Key"
    style="
    background-color: transparent;
    overflow: hidden; /* Hide scrollbars */
    resize: none; /* Prevent manual resizing */
  "
    onclick="event.stopPropagation();"
    readonly
  ></textarea>


    <button id="generate-private-and-public-key" class="toolbar-column-btns" style="color: black; display: block; width: 48vw">Generate</button>
  </div>
  </div>
  </div>

    <div
      id="marker-column"
      style="display: none; position: absolute; z-index: 1002;"
    >
      <div id="marker-column-container" 
      class="toolbar-containers"
      onclick="event.stopPropagation();"
      >
      <div class="toolbar-group">
        <textarea
          class="toolbar-column"
          type="text"
          id="input-field-2-0"
          placeholder="Domain/Topic ID"
          onclick="event.stopPropagation();"
          style="background-color: transparent;"
          oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
          ></textarea>
          <textarea
          class="toolbar-column"
          type="text"
          id="input-field-number-of-marker"
          placeholder="Number of marker"
          style="
          background-color: transparent;
          overflow: hidden; /* Hide scrollbars */
          resize: none; /* Prevent manual resizing */
          "
        oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
        ></textarea>
        <textarea
        class="toolbar-column"
        type="text"
        id="input-field-2-3"
        placeholder="Coordinates long,lat"
        style="
        background-color: transparent;
        overflow: hidden; /* Hide scrollbars */
        resize: none; /* Prevent manual resizing */
        margin-bottom: 0vh !important;
      "
      oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
      onclick="event.stopPropagation();"
      ></textarea>
    </div>
        <textarea
        class="toolbar-column"
        type="text"
        id="input-field-coverimage-marker"
        placeholder="Cover Image URL"
        style="
        background-color: transparent;
        overflow: hidden; /* Hide scrollbars */
        resize: none; /* Prevent manual resizing */
        "
      oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
      onclick="event.stopPropagation();"
      ></textarea>

        <textarea
          class="toolbar-column"
          type="text"
          id="input-field-2-1"
          placeholder="Title"
          style="
          background-color: transparent;
          overflow: hidden; /* Hide scrollbars */
          resize: none; /* Prevent manual resizing */
        "
        onclick="event.stopPropagation();"
        oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
        ></textarea>
        <textarea
        class="toolbar-column"
        type="text"
        id="input-field-image-marker"
        placeholder="Image URL"
        style="
        background-color: transparent;
        overflow: hidden; /* Hide scrollbars */
        resize: none; /* Prevent manual resizing */
      "
      onclick="event.stopPropagation();"
      oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
      ></textarea>
        <textarea
          class="toolbar-column"
          type="text"
          id="input-field-2-2"
          placeholder="Message"
          style="
          background-color: transparent;
          overflow: hidden; /* Hide scrollbars */
          resize: none; /* Prevent manual resizing */
        "
        onclick="event.stopPropagation();"
        oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
        ></textarea>
        <button id="submit-button-column2" class="toolbar-column-btns">
          Submit
        </button>
        <label for="loaded-topics" style=" font-size: 2vh;padding: 0px;">Loaded Topic Rules:</label>
        <textarea
        class="toolbar-column"
        type="text"
        id="loaded-topic-rules-for-marker"
        placeholder="Loaded Topic Rules"
        style="
        background-color: transparent;
        overflow: hidden; /* Hide scrollbars */
        resize: none; /* Prevent manual resizing */
      "
      onclick="event.stopPropagation();"
        readonly
        oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
        ></textarea>
        <button id="load-topic-rules-for-marker" class="toolbar-column-btns">
          Load Topic Rules
        </button>
      </div>
    </div>

    <div
      id="polygon-column"
      style="display: none; position: absolute; z-index: 1002;"
    >
      <div id="polygon-column-container"       
      class="toolbar-containers"
      onclick="event.stopPropagation();"
      >
      <div class="toolbar-group">
      <textarea
        class="toolbar-column"
        type="text"
        id="input-field-3-0"
        placeholder="Domain/Topic ID"
        style="
        background-color: transparent;
      "
        onclick="event.stopPropagation();"
        oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
        ></textarea>
        <textarea
        class="toolbar-column"
        type="text"
        id="input-field-number-of-polygon"
        placeholder="Number of polygon"
        style="
        background-color: transparent;
        overflow: hidden; /* Hide scrollbars */
        resize: none; /* Prevent manual resizing */
        "
      oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
      ></textarea>
      <textarea
      class="toolbar-column"
      type="text"
      id="input-field-3-3"
      placeholder="TOP LEFT long,lat"
      style="
      background-color: transparent;
    "
    onclick="event.stopPropagation();"
    oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
    ></textarea>

    <textarea
      class="toolbar-column"
      type="text"
      id="input-field-3-5"
      placeholder="BOTTOM RIGHT long,lat"
      style="
      background-color: transparent;
"
    onclick="event.stopPropagation();"
    oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
    ></textarea>
  </div>
      <textarea
      class="toolbar-column"
      type="text"
      id="input-field-coverimage-polygon"
      placeholder="Cover Image URL"
      style="
      background-color: transparent;
      "
      onclick="event.stopPropagation();"
      oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
      ></textarea>
      <textarea
        class="toolbar-column"
        type="text"
        id="input-field-3-1"
        placeholder="Title"
        style="
        background-color: transparent;
      "
      onclick="event.stopPropagation();"
      oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
      ></textarea>
      <textarea
      class="toolbar-column"
      type="text"
      id="input-field-image-polygon"
      placeholder="Image URL"
      style="
      background-color: transparent;
    "
    onclick="event.stopPropagation();"
    oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
    ></textarea>
      <textarea
        class="toolbar-column"
        id="input-field-3-2"
        placeholder="Message"
        style="
        background-color: transparent;
      "
      onclick="event.stopPropagation();"
        oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
      ></textarea>
      


      <button id="submit-button-column3" class="toolbar-column-btns" style="color: black; display: block; width: 48vw">
        Submit
      </button>
      <label for="loaded-topics" style=" font-size: 2vh;padding: 0px;">Loaded Topic Rules:</label>
      <textarea
      class="toolbar-column"
      type="text"
      id="loaded-topic-rules-for-polygon"
      placeholder="Loaded Topic Rules"
      style="
      background-color: transparent;
      overflow: hidden; /* Hide scrollbars */
      resize: none; /* Prevent manual resizing */
    "
    onclick="event.stopPropagation();"
      readonly
      ></textarea>
      <button id="load-topic-rules-for-polygon" class="toolbar-column-btns">
        Load Topic Rules
      </button>
    </div>
    </div>

    <div
    id="rules-column"
    style="display: none; position: absolute; z-index: 1002;"
  >
    <div id="rules-column-container"
    class="toolbar-containers"
    onclick="event.stopPropagation();"
    >
<textarea
  class="toolbar-column"
  type="text"
  id="input-field-topic-id-for-rules"
  placeholder="Domain/Topic ID"
  style="
  background-color: transparent;
"
onclick="event.stopPropagation();"
oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
></textarea>
<label for="loaded-topics" style=" font-size: 2vh;padding: 0px;">Loaded Topic Rules:</label>
<textarea
class="toolbar-column"
type="text"
id="loaded-topic-rules-for-topic"
placeholder="Loaded Topic Rules"
style="
background-color: transparent;
overflow: hidden; /* Hide scrollbars */
resize: none; /* Prevent manual resizing */
"
onclick="event.stopPropagation();"
readonly
></textarea>
<button id="load-topic-rules-for-topic" class="toolbar-column-btns">
  Load Topic Rules
</button>
<label for="input-field-rules-for-polygons"style="font-size: 2vh; padding: 0px;">These come in pair and they overwrite last set:</label>

<div class="toolbar-group">
<div style="margin-bottom: 0px;">
<label for="input-field-rules-for-polygons"style="font-size: 2vh; padding: 0px;">For polygons:</label>
<textarea
  class="toolbar-column"
  type="text"
  id="input-field-topic-id-for-polygons"
  placeholder="NFT ID (set to zero to allow all)"
  style="
    background-color: transparent;
  "
  onclick="event.stopPropagation();"
  oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
  ></textarea>
</div>

  <textarea
  class="toolbar-column"
  type="text"
  id="input-field-messages-per-nft-for-polygons"
  placeholder="how many polygons per NFT"
  style="
    background-color: transparent;
  "
  onclick="event.stopPropagation();"
  oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
  ></textarea>

<textarea
  class="toolbar-column"
  type="text"
  id="input-field-messages-size-for-polygons"
  placeholder="max size = (360,180) / (number)"
  style="
  background-color: transparent;
"
onclick="event.stopPropagation();"
oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
></textarea>

<div style="margin-bottom: 10px;">
<label for="input-field-add-rules" style=" font-size: 2vh;padding: 0px;">For markers:</label>
<textarea
  class="toolbar-column"
  type="text"
  id="input-field-topic-id-for-markers"
  placeholder="NFT ID (set to zero to allow all)"
  style="
    background-color: transparent;
  "
  onclick="event.stopPropagation();"
  oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
  ></textarea>
</div>

  <textarea
  class="toolbar-column"
  type="text"
  id="input-field-messages-per-nft-for-markers"
  placeholder="how many markers per NFT"
  style="
    background-color: transparent;
  "
  onclick="event.stopPropagation();"
  oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
  ></textarea>
<button id="submit-button-set-rules" class="toolbar-column-btns" style="color: black; display: block; width: 48vw">Submit</button>
<div style="margin-bottom: 10px;"></div>
</div>
<label for="input-field-add-remove-NFT-for-model" style=" font-size: 2vh;padding: 0px;"> Model sharing:</label>
<textarea
  class="toolbar-column"
  type="text"
  id="input-field-add-remove-NFT-for-model"
  placeholder="NFT ID (or IDs seperated by commas)"
  style="
    background-color: transparent;
  "
  onclick="event.stopPropagation();"
  oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
  ></textarea>
<div class="button-group" style="display: flex; flex-direction: row; align-items: center;">
  <button id="submit-button-add-NFT-for-model" class="toolbar-column-btns" style="color: black; width: 20vw;">Add</button>
  <button id="submit-button-remove-NFT-for-model" class="toolbar-column-btns" style="color: black; width: 20vw; margin-left: 8vw;">Remove</button>
</div>

<label for="input-field-add-remove-scale-for-model" style=" font-size: 2vh;padding: 0px;">Model scale factor:</label>
<textarea
  class="toolbar-column"
  type="text"
  id="input-field-add-remove-scale-for-model"
  placeholder="scale (only one NFT at a time)"
  style="
    background-color: transparent;
  "
  onclick="event.stopPropagation();"
  oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
  ></textarea>
<div class="button-group" style="display: flex; flex-direction: row; align-items: center;">
  <button id="submit-button-add-scale-for-model" class="toolbar-column-btns" style="color: black; width: 20vw;">Add</button>
  <button id="submit-button-remove-scale-for-model" class="toolbar-column-btns" style="color: black; width: 20vw; margin-left: 8vw;">Remove</button>
</div>


<label for="input-field-add-remove-topic-chat" style=" font-size: 2vh;padding: 0px;">Topic Chat:</label>
<textarea
  class="toolbar-column"
  type="text"
  id="input-field-add-remove-topic-chat"
  placeholder="NFT ID (or IDs seperated by commas)"
  style="
    background-color: transparent;
  "
  onclick="event.stopPropagation();"
  oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
  ></textarea>
<div class="button-group" style="display: flex; flex-direction: row; align-items: center;">
  <button id="submit-button-add-topic-chat" class="toolbar-column-btns" style="color: black; width: 20vw;">Add</button>
  <button id="submit-button-remove-topic-chat" class="toolbar-column-btns" style="color: black; width: 20vw; margin-left: 8vw;">Remove</button>
</div>



</div>
</div>
  </div>

    <div
    id="memo-column"
    style="display: none; position: absolute; z-index: 1002;"
  >
    <div id="memo-column-container"
    class="toolbar-containers"
    onclick="event.stopPropagation();"
    >
    <div class="toolbar-group">
  <textarea
  class="toolbar-column"
  type="text"
  id="input-field-topic-id"
  placeholder="Domain/Topic ID"
  style="
    background-color: transparent;
  "
  onclick="event.stopPropagation();"
  oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
  ></textarea>

    <textarea
      class="toolbar-column"
      type="text"
      id="input-field-admin-key"
      placeholder="public key"
      style="
    background-color: transparent;
    overflow: hidden; /* Hide scrollbars */
    resize: none; /* Prevent manual resizing */
  "
  onclick="event.stopPropagation();"
  oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
    ></textarea>

    <textarea
      class="toolbar-column"
      type="text"
      id="input-field-memo"
      placeholder="Admins 0.0.1,0.0.2.."
      style="
    background-color: transparent;
    overflow: hidden; /* Hide scrollbars */
    resize: none; /* Prevent manual resizing */
  "
  onclick="event.stopPropagation();"
  oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
  ></textarea>
</div>
<label for="public-key-label"style="font-size: 2vh; padding: 0px;">Optional fee for each message:</label>

  <div class="toolbar-group">
<textarea
class="toolbar-column"
type="text"
id="input-field-fee"
placeholder="Set amount of fee"
style="
  background-color: transparent;
  overflow: hidden; /* Hide scrollbars */
  resize: none; /* Prevent manual resizing */
"
onclick="event.stopPropagation();"
oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
></textarea>
<textarea
class="toolbar-column"
type="text"
id="input-field-fee-token"
placeholder="Set token id of fee"
style="
  background-color: transparent;
  overflow: hidden; /* Hide scrollbars */
  resize: none; /* Prevent manual resizing */
"
onclick="event.stopPropagation();"
oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
></textarea>
<textarea
class="toolbar-column"
type="text"
id="input-field-royal-acc"
placeholder="Set royalty account"
style="
  background-color: transparent;
  overflow: hidden; /* Hide scrollbars */
  resize: none; /* Prevent manual resizing */
"
onclick="event.stopPropagation();"
oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
></textarea>
</div>
    <button id="submit-button-change-memo" class="toolbar-column-btns" style="color: black; display: block; width: 48vw">Submit</button>

    </div>
  </div>

  <div id="stack-topic-ids" style="display: none; position: absolute; z-index: 1002;">
    <div
      id="stack-topic-ids-container"
      class="toolbar-containers"
      onclick="event.stopPropagation();"
      >
      
    <textarea
    class="toolbar-column"
    type="text"
    id="stack-topic-ids-topic"
    placeholder="Domain/Topic ID"
    style="
    background-color: transparent;
    overflow: hidden; /* Hide scrollbars */
    resize: none; /* Prevent manual resizing */
  "
  onclick="event.stopPropagation();"
  oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
  ></textarea>

    <textarea
    class="toolbar-column"
    type="text"
    id="stack-topic-add-topic"
    placeholder="0.0.1,0.0.2.."
    style="
    background-color: transparent;
    overflow: hidden; /* Hide scrollbars */
    resize: none; /* Prevent manual resizing */
  "
  onclick="event.stopPropagation();"
  oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
  ></textarea>

      <button id="add-topic-id" class="toolbar-column-btns" style="color: black; display: block; width: 48vw">Stack</button>

      <textarea
      class="toolbar-column"
      type="text"
      id="stack-topic-remove-topic"
      placeholder="0.0.1,0.0.2.."
      style="
    background-color: transparent;
    overflow: hidden; /* Hide scrollbars */
    resize: none; /* Prevent manual resizing */
  "
  onclick="event.stopPropagation();"
  oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
    ></textarea>
  
        <button id="remove-topic-id" class="toolbar-column-btns" style="color: black; display: block; width: 48vw">Remove</button>
    </div>
  </div>

    <div class="flex-container">
      <div id="wallet-section">
        <button id="connect-wallet-btn">Connect Wallet</button>
        <button id="disconnect-wallet-btn">Disconnect</button>
        <div class="account-info">
          <div id="account-id" style="margin-left: 0.3vh;"></div>
        </div>
      </div>
    </div>

    <div id="left-dpad" class="button-container">
      <button class="touch-button" style="visibility: hidden;"></button>
      <button id="left-up" class="touch-button"></button>
      <button class="touch-button" style="visibility: hidden;"></button>
      <button id="left-left" class="touch-button"></button>
      <button class="touch-button" style="visibility: hidden;"></button>
      <button id="left-right" class="touch-button"></button>
      <button class="touch-button" style="visibility: hidden;"></button>
      <button id="left-down" class="touch-button"></button>
      <button class="touch-button" style="visibility: hidden;"></button>
    </div>
    
    <div id="right-dpad" class="button-container">
      <button class="touch-button" style="visibility: hidden;"></button>
      <button id="right-up" class="touch-button"></button>
      <button class="touch-button" style="visibility: hidden;"></button>
      <button id="right-left" class="touch-button"></button>
      <button class="touch-button" style="visibility: hidden;"></button>
      <button id="right-right" class="touch-button"></button>
      <button class="touch-button" style="visibility: hidden;"></button>
      <button id="right-down" class="touch-button"></button>
      <button class="touch-button" style="visibility: hidden;"></button>
    </div>

    <div id="zoom-controls">
      <button id="zoom-in" class="zoom-button">+</button>
      <button id="zoom-out" class="zoom-button">-</button>
    </div>

    <input type="range" id="speed-slider" min="0.1" max="5" step="0.01" value="1" style="display: none;" />

    <button id="toggle-controls-btn" style="
      position: fixed;
      top: 6.5vh;
      left: 0;
      z-index: 1006;
      background-color: #007bff;
      color: white;
      border: none;
      padding: 0.8vh 1vw;
      border-radius: 0.8vh;
      cursor: pointer;
      font-size: 1.5vh;
      display: none;
      margin-left: 0.3vh;
    ">Controls</button>

    <button id="toggle-toolbar-btn" style="
      position: fixed;
      top: 15.5vh;
      left: 0;
      z-index: 1006;
      background-color: #007bff;
      color: white;
      border: none;
      padding: 0.8vh 1vw;
      border-radius: 0.8vh;
      cursor: pointer;
      font-size: 1.5vh;
      display: none;
      margin-left: 0.3vh;
    ">Toolbar</button>

<div style="display: flex; position: fixed; top: 6.5vh; left: 0; z-index: 1006;">
  <button id="main-toggle-btn" style="
    background-color: #007bff;
    color: white;
    border: none;
    padding: 0.8vh 1vw;
    border-radius: 0.8vh;
    cursor: pointer;
    font-size: 1.5vh;
    margin-left: 0.3vh;
  ">Options</button>

  <button id="topic-chat-btn" style="
    background-color: rgb(0, 123, 255);
    color: white;
    border: none;
    padding: 0.8vh 1vw;
    border-radius: 0.8vh;
    cursor: pointer;
    font-size: 1.5vh;
    margin-left: 1vw; /* Add some space between buttons */
  ">Topic Chat</button>
</div>


<div id="topic-chat-container" class="topic-chat-container" style="display: none; position: absolute; z-index: 1002; top: 10vh; left: 0; width: 100vw;
    scrollbar-width: thin; /* Firefox */
    scrollbar-color: #888 #f1f1f1; /* Firefox */
    ">

  <div style="          
  color: white;
  padding: 1vh 1vw;
  box-sizing: border-box;
  border-radius: 1vh;
"  onclick="event.stopPropagation();"

>

<div style="display: flex; align-items: center; margin-bottom: 1vh;">

  <textarea
  class="toolbar-column"
  type="text"
  id="topic-chat-topic-id"
  placeholder="Domain/Topic ID"
  style="background-color: transparent;"
  onclick="event.stopPropagation();"
  oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
  ></textarea>
  <button id="load-msgs-from" class="toolbar-column-btns" style="color: white; text-shadow: 0 0 0.5vh black; margin-left: 1vw;">Use</button>
</div>

<div style="display: flex; align-items: center; margin-bottom: 1vh;"> 
  <input type="number" id="from-mmddyyyy" class="toolbar-column-btns" step="1" placeholder="MMDDYYYY" />
  <input type="number" id="to-mmddyyyy" class="toolbar-column-btns" step="1" placeholder="MMDDYYYY" style="margin-left: 1vw;" />
  <button id="topic-msgs-filter" class="toolbar-column-btns" style="width: 50vw; color: white; text-shadow: 0 0 0.5vh black; margin-left: 1vw;">Filter</button> <!-- Changed width to auto -->
</div>

<div style="display: flex; align-items: center; margin-bottom: 1vh;"> 
  <input type="number" id="from-hhmmss" class="toolbar-column-btns" step="1" placeholder="HHMMSS" />
  <input type="number" id="to-hhmmss" class="toolbar-column-btns" step="1" placeholder="HHMMSS" style="margin-left: 1vw;" />
  <button id="topic-msgs-filter-time" class="toolbar-column-btns" style="width: 50vw; color: white; text-shadow: 0 0 0.5vh black; margin-left: 1vw;">Filter</button> <!-- Changed width to auto -->
</div>

<div
  class="toolbar-column"
  id="messages-from-topic-chat"
  style="
    background-color: transparent;
    max-height: 50vh; /* Set maximum height */
    overflow-y: scroll; /* Explicitly enable vertical scrolling */
    user-select: text; /* Allow text selection */
    scrollbar-width: thin; /* Firefox */
    scrollbar-color: #888 #f1f1f1; /* Firefox */
    -webkit-overflow-scrolling: touch; /* Enable momentum scrolling on iOS */
    touch-action: auto; /* Ensure touch actions are allowed */
  "
  onclick="event.stopPropagation();"
>
  <textarea
    style="
      width: 100%;
      height: 100px;
      resize: none; /* Prevent manual resizing */
      overflow: auto; /* Enable scrolling */
      background-color: transparent;
      border: none;
    "
    onfocus="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"
  ></textarea>
</div>


<div style="position: relative;">
  <textarea
    class="toolbar-column"
    type="text"
    id="user-write-message"
    placeholder="Write a message (max 256 characters)"
    style="
      background-color: transparent;
      max-height: 50vh;
      overflow: auto;
    "
    onclick="event.stopPropagation();"
    oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px'; document.getElementById('char-counter').textContent = this.value.length + '/256';"
    maxlength="256"
  ></textarea>
  <div id="char-counter" style="position: absolute; bottom: 5px; right: 10px; font-size: 2vh; color: #666;">
    0/256
  </div>
</div>

    <div style="display: flex; align-items: center; margin-top: 1.5vh;"> 
      <button id="go-to-top-msgs" class="toolbar-column-btns" style="width: 50vw; color: white; text-shadow: 0 0 0.5vh black; ">Go to the top</button> <!-- Changed width to auto -->
      <button id="post-msg" class="toolbar-column-btns" style="width: 50vw; color: white; text-shadow: 0 0 0.5vh black; margin-left: 1vw ">Submit Message</button> <!-- Changed width to auto -->
    </div>


  </div>

</div>




    <div id="rotation-controls" style="position: fixed;
    display: flex;
    flex-direction: column;
    background-color: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 1vh 1vw;
    border-radius: 1vh;
    z-index: 1001;
    justify-content: space-around;
    width: 98%;
    top: 10vh;
    left: 0;
    transform: none;
    display: none;"
    onclick="event.stopPropagation();">

      <div class="toolbar-column" id="change-model-settings">Change model settings</div>
      <div class="toolbar-column" id="change-crosshair-settings" style="width: 98vw;">Change crosshair settings</div>

    </div>





    
      <div id="model-column" style="display: none; position: absolute; z-index: 1002; top: 10vh; left: 0; width: 100vw;">
        <div
        id="model-column-container"
        style="
          background-color: rgba(0, 0, 0, 0);
          color: white;
          padding: 1vh 1vw;
          box-sizing: border-box;
          border-radius: 1vh;
        "
        onclick="event.stopPropagation();"
        >

        <input 
        type="text" 
        class="toolbar-column"
        id="object-input"
        placeholder="Enter URL"
        style="
    background-color: transparent;
    overflow: hidden; /* Hide scrollbars */
    resize: none; /* Prevent manual resizing */
    text-align: center; /* Center-align the text */
  "
        onclick="event.stopPropagation();"
        />
        <button id="buttonforobject" class="toolbar-column-btns" 
        style="text-shadow: 0 0 0.5vh black;
        margin-top: 1vh;
        ">Change object</button>


        <div style="display: flex; align-items: center; padding-left: 1vh; padding-bottom: 1vh; padding-top: 1vh;">
            <label for="rotation-x"
            class="toolbar-column"
            style="
            background-color: transparent;
            overflow: hidden; /* Hide scrollbars */
            resize: none; /* Prevent manual resizing */
            text-align: left; /* Center-align the text */
            text-shadow: 0 0 0.5vh black;
          ">Rotation X:</label>
            <input type="range" class="toolbar-column" style="
                            margin-left: 5vw;
                            margin-right: 5vw;
            background-color: transparent;
            overflow: hidden; /* Hide scrollbars */
            resize: none; /* Prevent manual resizing */
          " id="rotation-x" min="0" max="360" value="0"/>
            <input type="number" class="toolbar-column" style="
            background-color: transparent;
            overflow: hidden; /* Hide scrollbars */
            resize: none; /* Prevent manual resizing */
            text-align: center; /* Center-align the text */
            text-shadow: 0 0 0.5vh black;
          " id="rotation-x-value"
           value="0" onchange="document.getElementById('rotation-x').value = this.value;" />
        </div>
        <div style="display: flex; align-items: center; padding-left: 1vh; padding-bottom: 1vh;">
            <label for="rotation-y"
            class="toolbar-column"
            style="
            background-color: transparent;
            overflow: hidden; /* Hide scrollbars */
            resize: none; /* Prevent manual resizing */
            text-align: left; /* Center-align the text */
            text-shadow: 0 0 0.5vh black;
          ">Rotation Y:</label>
            <input type="range" class="toolbar-column" style="
                            margin-left: 5vw;
                            margin-right: 5vw;
            background-color: transparent;
            overflow: hidden; /* Hide scrollbars */
            resize: none; /* Prevent manual resizing */
          " id="rotation-y" min="0" max="360" value="0"/>
            <input type="number" class="toolbar-column" id="rotation-y-value" 
            style="
            background-color: transparent;
            overflow: hidden; /* Hide scrollbars */
            resize: none; /* Prevent manual resizing */
            text-align: center; /* Center-align the text */
            text-shadow: 0 0 0.5vh black;
          " value="0" onchange="document.getElementById('rotation-y').value = this.value;" />
        </div>
        <div style="display: flex; align-items: center; padding-left: 1vh; padding-bottom: 1vh;">
            <label for="rotation-z"
            class="toolbar-column"
            style="
            background-color: transparent;
            overflow: hidden; /* Hide scrollbars */
            resize: none; /* Prevent manual resizing */
            text-align: left; /* Center-align the text */
            text-shadow: 0 0 0.5vh black;
          ">Rotation Z:</label>
            <input type="range" class="toolbar-column" style="
                            margin-left: 5vw;
                            margin-right: 5vw;
            background-color: transparent;
            overflow: hidden; /* Hide scrollbars */
            resize: none; /* Prevent manual resizing */
          " id="rotation-z" min="0" max="360" value="0"/>
            <input type="number" class="toolbar-column" id="rotation-z-value" 
            style="
            background-color: transparent;
            overflow: hidden; /* Hide scrollbars */
            resize: none; /* Prevent manual resizing */
            text-align: center; /* Center-align the text */
            text-shadow: 0 0 0.5vh black;
          " value="0" onchange="document.getElementById('rotation-z').value = this.value;" />
        </div>
        <div style="display: flex; align-items: center; padding-left: 1vh; padding-bottom: 1vh;">
            <label for="position-x"
            class="toolbar-column"
            style="
            background-color: transparent;
            overflow: hidden; /* Hide scrollbars */
            resize: none; /* Prevent manual resizing */
            text-align: left; /* Center-align the text */
            text-shadow: 0 0 0.5vh black;
          ">Position X:</label>
            <input type="range" class="toolbar-column" style="
                            margin-left: 5vw;
                            margin-right: 5vw;
            background-color: transparent;
            overflow: hidden; /* Hide scrollbars */
            resize: none; /* Prevent manual resizing */
          " id="position-x" min="-100" max="100" step="0.1" value="0"/>
            <input type="number" class="toolbar-column" id="position-x-value" 
            style="
            background-color: transparent;
            overflow: hidden; /* Hide scrollbars */
            resize: none; /* Prevent manual resizing */
            text-align: center; /* Center-align the text */
            text-shadow: 0 0 0.5vh black;
          " value="0" onchange="document.getElementById('position-x').value = this.value;" />
        </div>
        <div style="display: flex; align-items: center; padding-left: 1vh; padding-bottom: 1vh;">
            <label for="position-y"    class="toolbar-column" style="
            background-color: transparent;
            overflow: hidden; /* Hide scrollbars */
            resize: none; /* Prevent manual resizing */
            text-align: left; /* Center-align the text */
            text-shadow: 0 0 0.5vh black;
          ">Position Y:</label>
            <input type="range" class="toolbar-column" style="
                            margin-left: 5vw;
                            margin-right: 5vw;
            background-color: transparent;
            overflow: hidden; /* Hide scrollbars */
            resize: none; /* Prevent manual resizing */
          " id="position-y" min="-100" max="100" step="0.1" value="0"/>
            <input type="number" class="toolbar-column" id="position-y-value" 
            style="
            background-color: transparent;
            overflow: hidden; /* Hide scrollbars */
            resize: none; /* Prevent manual resizing */
            text-align: center; /* Center-align the text */
            text-shadow: 0 0 0.5vh black;
          " value="0" onchange="document.getElementById('position-y').value = this.value;" />
        </div>
        <div style="display: flex; align-items: center; padding-left: 1vh; padding-bottom: 1vh;">
            <label for="position-z"   class="toolbar-column" style="
            background-color: transparent;
            overflow: hidden; /* Hide scrollbars */
            resize: none; /* Prevent manual resizing */
            text-align: left; /* Center-align the text */
            text-shadow: 0 0 0.5vh black;
          ">Position Z:</label>
            <input type="range" class="toolbar-column" style="
                            margin-left: 5vw;
                            margin-right: 5vw;
            background-color: transparent;
            overflow: hidden; /* Hide scrollbars */
            resize: none; /* Prevent manual resizing */
          " id="position-z" min="-100" max="100" step="0.1" value="0"/>
            <input type="number" class="toolbar-column" id="position-z-value" 
            style="
            background-color: transparent;
            overflow: hidden; /* Hide scrollbars */
            resize: none; /* Prevent manual resizing */
            text-align: center; /* Center-align the text */
            text-shadow: 0 0 0.5vh black;
          " value="0" onchange="document.getElementById('position-z').value = this.value;" />
        </div>
        <div style="display: flex; align-items: center; padding-left: 1vh; padding-bottom: 1vh;">
            <label for="scale-factor" class="toolbar-column" style="
            background-color: transparent;
            overflow: hidden; /* Hide scrollbars */
            resize: none; /* Prevent manual resizing */
            text-align: left; /* Center-align the text */
            text-shadow: 0 0 0.5vh black;
          ">Scale Factor:</label>
            <input type="range" class="toolbar-column" style="
                            margin-left: 5vw;
                            margin-right: 5vw;
            background-color: transparent;
            overflow: hidden; /* Hide scrollbars */
            resize: none; /* Prevent manual resizing */
          " id="scale-factor" step="0.000001" value="1"/>
            <input type="number" class="toolbar-column" id="scale-factor-value" 
            style="
            background-color: transparent;
            overflow: hidden; /* Hide scrollbars */
            resize: none; /* Prevent manual resizing */
            text-align: center; /* Center-align the text */
            text-shadow: 0 0 0.5vh black;
          " value="1" onchange="document.getElementById('scale-factor').value = this.value;" />
        </div>
        <button id="savesettings" class="toolbar-column-btns" style="text-shadow: 0 0 0.5vh black;">Save settings</button>

            </div>
        </div>
      </div>





      <div id="visibility-controls" style="display: none; position: absolute; z-index: 1002; top: 10vh; left: 0; width: 100vw;">

        <div style="          background-color: rgba(0, 0, 0, 0.2);
        color: white;
        padding: 1vh 1vw;
        box-sizing: border-box;
        border-radius: 1vh;
      ">



          <div style="display: flex; align-items: center; margin-bottom: 1vh;"> 
            <label for="time-input" style="font-size: 2vh; padding-bottom: 0.5vh; color: white; text-shadow: 0 0 0.5vh black;">Enter a time of update in milliseconds:</label>
          </div>

          <div style="display: flex; align-items: center; margin-bottom: 1vh;"> 
            <input type="number" id="time-input" class="toolbar-column-btns" />
            <button id="update-loop" class="toolbar-column-btns" style="width: 50vw;  margin-left: 1vw; color: white; text-shadow: 0 0 0.5vh black;">Update time</button> <!-- Changed width to auto -->
          </div>

          <div style="display: flex; align-items: center; padding-left: 1vh; padding-bottom: 1vh;">
            <label for="raster-opacity-slider" style="font-size: 2vh; padding-bottom: 0.5vh; color: white; text-shadow: 0 0 0.5vh black;">
              Polygon transparency:</label>

              <input type="range" id="raster-opacity-slider" min="0" max="1" step="0.01" value="1" class="toolbar-column" style="
              background-color: transparent;
              overflow: hidden; /* Hide scrollbars */
              resize: none; /* Prevent manual resizing */
              color: white;
              text-shadow: 0 0 0.5vh black;
            " >
          </div>

          <div style="display: flex; align-items: center; margin-bottom: 1vh;"> 
            <button id="toggle-polygon-visibility" class="toolbar-column-btns" style="width: 50vw; color: white; text-shadow: 0 0 0.5vh black;">Show polygons:</button> <!-- Changed width to auto -->
            <span id="polygon-visibility-value" style="font-size: 2vh; padding-bottom: 0.5vh; color: white; text-shadow: 0 0 0.5vh black;">On</span> <!-- Updated to reflect button state -->
          </div>

          <div style="display: flex; align-items: center; margin-bottom: 1vh;"> 
            <button id="toggle-marker-visibility" class="toolbar-column-btns" style="width: 50vw; color: white; text-shadow: 0 0 0.5vh black;">Show markers</button> <!-- Changed width to auto -->
            <span id="marker-visibility-value" style="font-size: 2vh; padding-bottom: 0.5vh; color: white; text-shadow: 0 0 0.5vh black;">On</span> <!-- Updated to reflect button state -->
          </div>

          <div style="display: flex; align-items: center; margin-bottom: 1vh;"> 
            <button id="toggle-3d-model-visibility" class="toolbar-column-btns" style="width: 50vw; color: white; text-shadow: 0 0 0.5vh black;">Show 3D models</button> <!-- Changed width to auto -->
            <span id="3d-model-visibility-value" style="font-size: 2vh; padding-bottom: 0.5vh; color: white; text-shadow: 0 0 0.5vh black;">On</span> <!-- Updated to reflect button state -->
          </div>

          <div style="display: flex; align-items: center; margin-bottom: 1vh;"> 
            <button id="toggle-updates" class="toolbar-column-btns" style="width: 50vw; color: white; text-shadow: 0 0 0.5vh black;">model updates</button> <!-- Changed width to auto -->
            <span id="updates-value" style="font-size: 2vh; padding-bottom: 0.5vh; color: white; text-shadow: 0 0 0.5vh black;">On</span> <!-- Updated to reflect button state -->
          </div>

          <div style="display: flex; align-items: center; margin-bottom: 1vh;"> 
            <button id="update-map-layer-btn" class="toolbar-column-btns" style="width: 50vw; color: white; text-shadow: 0 0 0.5vh black;">Update Map</button>
          </div>

          
        </div>

      </div>






      <div id="crosshair-column" style="display: none; position: absolute; z-index: 1002; top: 10vh; left: 0; width: 100vw;">
        <div
        id="crosshair-column-container"
        style="
          background-color: rgba(0, 0, 0, 0);
          color: white;
          padding: 1vh 1vw;
          box-sizing: border-box;
          border-radius: 1vh;
        "
        onclick="event.stopPropagation();"
      >


            <div style="display: flex; align-items: center; padding-bottom: 1vh;" >
                <label for="color-red" class="toolbar-column" style="
                background-color: transparent;
                overflow: hidden; /* Hide scrollbars */
                resize: none; /* Prevent manual resizing */
                text-align: left; /* Center-align the text */
                text-shadow: 0 0 0.5vh black;
              ">Red:</label>
                <input type="range" class="toolbar-column" style="
                                margin-left: 5vw;
                                margin-right: 5vw;
                background-color: transparent;
                overflow: hidden; /* Hide scrollbars */
                resize: none; /* Prevent manual resizing */
              "  id="color-red" min="0" max="255" value="255"/>
                <input type="number" id="color-red-value"   class="toolbar-column"          style="
                background-color: transparent;
                overflow: hidden; /* Hide scrollbars */
                resize: none; /* Prevent manual resizing */
                text-align: center; /* Center-align the text */
                text-shadow: 0 0 0.5vh black;
              " value="255" onchange="document.getElementById('color-red').value = this.value;" />
            </div>
            <div style="display: flex; align-items: center; padding-bottom: 1vh;" >
                <label for="color-green" class="toolbar-column" style="
                background-color: transparent;
                overflow: hidden; /* Hide scrollbars */
                resize: none; /* Prevent manual resizing */
                text-align: left; /* Center-align the text */
                text-shadow: 0 0 0.5vh black;
              ">Green:</label>
                <input type="range" class="toolbar-column" style="
                                                margin-left: 5vw;
                                                margin-right: 5vw;
                background-color: transparent;
                overflow: hidden; /* Hide scrollbars */
                resize: none; /* Prevent manual resizing */
              "  id="color-green" min="0" max="255" value="255"/>
                <input type="number" id="color-green-value" class="toolbar-column"          style="
                background-color: transparent;
                overflow: hidden; /* Hide scrollbars */
                resize: none; /* Prevent manual resizing */
                text-align: center; /* Center-align the text */
                text-shadow: 0 0 0.5vh black;
              " value="255" onchange="document.getElementById('color-green').value = this.value;" />
            </div>
            <div style="display: flex; align-items: center; padding-bottom: 1vh;" >
                <label for="color-blue" class="toolbar-column" style="
                background-color: transparent;
                overflow: hidden; /* Hide scrollbars */
                resize: none; /* Prevent manual resizing */
                text-align: left; /* Center-align the text */
                text-shadow: 0 0 0.5vh black;
              ">Blue:</label>
                <input type="range" class="toolbar-column" style="
                margin-left: 5vw;
                margin-right: 5vw;
                background-color: transparent;
                overflow: hidden; /* Hide scrollbars */
                resize: none; /* Prevent manual resizing */
              "  id="color-blue" min="0" max="255" value="255"/>
                <input type="number" id="color-blue-value" class="toolbar-column"          style="
                background-color: transparent;
                overflow: hidden; /* Hide scrollbars */
                resize: none; /* Prevent manual resizing */
                text-align: center; /* Center-align the text */
                text-shadow: 0 0 0.5vh black;
              " value="255" onchange="document.getElementById('color-blue').value = this.value;" />
            </div>
            <!-- New Sliders for Crosshair -->
            <div style="display: flex; align-items: center; padding-bottom: 1vh;" >
                <label for="crosshair-before-after" class="toolbar-column" style="
                background-color: transparent;
                overflow: hidden; /* Hide scrollbars */
                resize: none; /* Prevent manual resizing */
                text-align: left; /* Center-align the text */
                text-shadow: 0 0 0.5vh black;
              ">Length:</label>
                <input type="range" class="toolbar-column" style="
                                                margin-left: 5vw;
                                                margin-right: 5vw;
                background-color: transparent;
                overflow: hidden; /* Hide scrollbars */
                resize: none; /* Prevent manual resizing */
              "  id="crosshair-before-after" min="0" max="100" value="20"/>
                <input type="number" id="crosshair-before-after-value" class="toolbar-column"          style="
                background-color: transparent;
                overflow: hidden; /* Hide scrollbars */
                resize: none; /* Prevent manual resizing */
                text-align: center; /* Center-align the text */
                text-shadow: 0 0 0.5vh black;
              " value="20" onchange="document.getElementById('crosshair-before-after').value = this.value;" />
            </div>
            <div style="display: flex; align-items: center; padding-bottom: 1vh;" >
                <label for="crosshair-after-before" class="toolbar-column" style="
                background-color: transparent;
                overflow: hidden; /* Hide scrollbars */
                resize: none; /* Prevent manual resizing */
                text-align: left; /* Center-align the text */
                text-shadow: 0 0 0.5vh black;
              ">Thickness:</label>
                <input type="range" class="toolbar-column" style="
                                                margin-left: 5vw;
                                                margin-right: 5vw;
                background-color: transparent;
                overflow: hidden; /* Hide scrollbars */
                resize: none; /* Prevent manual resizing */
              "  id="crosshair-after-before" min="0" max="10" value="2"/>
                <input type="number" id="crosshair-after-before-value" class="toolbar-column"          style="
                background-color: transparent;
                overflow: hidden; /* Hide scrollbars */
                resize: none; /* Prevent manual resizing */
                text-align: center; /* Center-align the text */
                text-shadow: 0 0 0.5vh black;
              " value="2" onchange="document.getElementById('crosshair-after-before').value = this.value;" />
            </div>
            <div id="savecrosshair" class="toolbar-column-btns" style="text-shadow: 0 0 0.5vh black; text-align: center;">Save crosshair</div>
        </div>
      </div>
      </div>

    


    <div id="crosshair"></div>

    <button id="toggle-rotation-controls-btn" style="
      position: fixed;
      top: 20vh;
      left: 0;
      z-index: 1006;
      background-color: #007bff;
      color: white;
      border: none;
      padding: 0.8vh 1vw;
      border-radius: 0.8vh;
      cursor: pointer;
      font-size: 1.5vh;
      display: none; /* Initially hidden */
      margin-left: 0.3vh;
    ">Model</button>

    <button id="toggle-visibility-controls-btn" style="
      position: fixed;
      top: 11vh;
      left: 0;
      z-index: 1006;
      background-color: #007bff;
      color: white;
      border: none;
      padding: 0.8vh 1vw;
      border-radius: 0.8vh;
      cursor: pointer;
      font-size: 1.5vh;
      display: none; /* Initially hidden */
      margin-left: 0.3vh;
    ">Visibility</button>


<div class="popup-welcome-msg" id="welcome-msg" style="display: none;">
  <div class="popup-content-welcome">
    <p>Welcome to Hedera Network</p>
    <p>U must be connected via wallet to use this app.</p>
  </div>
</div>




  </body>

    <script>


      const APP_METADATA = {
        name: "PlanNet",
        description: "A Hashinals application using WalletConnect via Kiloscribe",
        url: "https://kiloscribe.com/",
        icons: ["https://kiloscribe.com/api/inscription-cdn/0.0.4819119"],
      };

      const PROJECT_ID = "fdd65bec25e85908fecf7561fe42b41f";

      let isToolbarOpen = false;
      let globalAccountId; // Declare an external variable to hold the accountId

      class Loader {
            constructor(totalCheckpoints) {
                this.totalCheckpoints = totalCheckpoints;
                this.currentCheckpoint = 0;
                this.progressBar = document.getElementById('progressBar');
                this.percentageText = document.getElementById('percentageText');
                this.loaderContainer = document.getElementById('loaderContainer');
                this.mainContent = document.getElementById('mainContent');
            }

            updateProgress() {
                this.currentCheckpoint++;
                const progress = Math.round((this.currentCheckpoint / this.totalCheckpoints) * 100);
                this.progressBar.style.width = progress + '%';
                this.percentageText.textContent = progress + '%';

                if (this.currentCheckpoint >= this.totalCheckpoints) {
                    setTimeout(() => {
                        this.loaderContainer.classList.add('hidden');
                    }, 500); // Small delay for smooth transition
                }
            }
        }

                // Initialize loader with number of checkpoints
                const loader = new Loader(10); // Set to number of checkpoints you want


                        // Simulate your code with checkpoints
        window.onload = () => {
          loader.updateProgress();
      window.HCSReady = async function () {

        const sdk = window.HashinalsWalletConnectSDK;
        const maplibregl = window.maplibregl;
        const Supercluster = window.Supercluster;
        const THREE = window.THREE;
        const scene = new THREE.Scene();

        async function ensureDracoLoaderReady() {
          for (let attempt = 1; attempt <= 5; attempt++) {
            if (typeof THREE !== 'undefined' && typeof THREE.DRACOLoader !== 'undefined') {
              try {
                new THREE.DRACOLoader();
                return true;
              } catch (e) {
              }
            }
            await new Promise(resolve => setTimeout(resolve, 200));
          }
        }

        await ensureDracoLoaderReady();

        // Define SelfContainedDRACOLoader inside HCSReady with explicit prototype binding
        function SelfContainedDRACOLoader() {


          // Create a base instance and extend it
          const baseLoader = Object.create(THREE.DRACOLoader.prototype);
          THREE.DRACOLoader.call(baseLoader);

          for (let prop in baseLoader) {
            if (baseLoader.hasOwnProperty(prop)) {
              this[prop] = baseLoader[prop];
              console.log(`Copied property ${prop} to this:`, this[prop]);
            }
          }

          this.decoderType = 'wasm';
          this.wasmBinary = null;
          this.jsWrapperBlob = null;
          this.jsWrapperUrl = null;
          this.jsDecoderBlob = null;
          this.jsDecoderUrl = null;

          this.initBlobs();
        }

        // Ensure prototype is correctly set
        if (!THREE.DRACOLoader.prototype) {
          throw new Error('THREE.DRACOLoader prototype is undefined.');
        }
        
        SelfContainedDRACOLoader.prototype = Object.create(THREE.DRACOLoader.prototype);
        SelfContainedDRACOLoader.prototype.constructor = SelfContainedDRACOLoader;

        SelfContainedDRACOLoader.prototype.initBlobs = function () {
          console.log('initBlobs method called on:', this);

          if (window.DRACO_WASM_BASE64) {
            const binaryString = atob(window.DRACO_WASM_BASE64);
            const bytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) bytes[i] = binaryString.charCodeAt(i);
            this.wasmBinary = bytes.buffer;
            console.log('WASM binary set, length:', bytes.length);
          }

          if (window.DRACO_JS_BASE64) {
            const jsText = atob(window.DRACO_JS_BASE64.split(',')[1]);
            this.jsWrapperBlob = new Blob([jsText], { type: 'application/javascript' });
            this.jsWrapperUrl = URL.createObjectURL(this.jsWrapperBlob);
            this.jsDecoderBlob = this.jsWrapperBlob;
            this.jsDecoderUrl = this.jsWrapperUrl;
            console.log('JS wrapper URL created:', this.jsWrapperUrl);
          } else {
            this.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/');
          }
        };

        SelfContainedDRACOLoader.prototype.setDecoderPath = function (path) {
          console.log('setDecoderPath called with path:', path);
          this.decoderPath = path;
        };

        SelfContainedDRACOLoader.prototype.getDecoderModule = function () {
          console.log('getDecoderModule called on:', this);
          if (this.decoderModule) {
            console.log('Returning cached decoder module');
            return Promise.resolve(this.decoderModule);
          }

          return new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = this.decoderType === 'wasm' ? this.jsWrapperUrl : this.jsDecoderUrl || `${this.decoderPath}draco_wasm_wrapper.js`;
            console.log('Loading decoder script from:', script.src);
            script.onload = () => {
              console.log('Decoder script loaded');
              if (typeof DracoDecoderModule !== 'undefined') {
                const moduleConfig = this.decoderType === 'wasm' ? { wasmBinary: this.wasmBinary } : {};
                DracoDecoderModule(moduleConfig).then((module) => {
                  this.decoderModule = module;
                  console.log('Decoder module initialized:', module);
                  resolve(module);
                }).catch(reject);
              } else {
                console.error('DracoDecoderModule not exposed');
                reject(new Error('DracoDecoderModule not exposed'));
              }
            };
            script.onerror = (e) => {
              console.error('Failed to load decoder script:', e);
              reject(e);
            };
            document.head.appendChild(script);
          });
        };

        SelfContainedDRACOLoader.prototype.dispose = function () {
          console.log('dispose called on:', this);
          if (typeof THREE.DRACOLoader.prototype.dispose === 'function') {
            THREE.DRACOLoader.prototype.dispose.call(this);
            console.log('Base dispose called');
          }
          if (this.jsWrapperUrl) {
            URL.revokeObjectURL(this.jsWrapperUrl);
            console.log('Revoked jsWrapperUrl');
          }
          if (this.jsDecoderUrl && this.jsDecoderUrl !== this.jsWrapperUrl) {
            URL.revokeObjectURL(this.jsDecoderUrl);
            console.log('Revoked jsDecoderUrl');
          }
        };

        // Expose globally, but only if not already defined
        if (!window.SelfContainedDRACOLoader) {
          window.SelfContainedDRACOLoader = SelfContainedDRACOLoader;
        }

        let dracoLoader;
        try {
          dracoLoader = new SelfContainedDRACOLoader();
        } catch (e) {
          dracoLoader = new THREE.DRACOLoader();
          dracoLoader.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/');
        }

        const ufoLoader = new THREE.GLTFLoader();
        ufoLoader.setDRACOLoader(dracoLoader);
        
// Function to load the UFO model
let currentUfoModel = null; // Declare outside the function to persist across calls

        async function updateAccountInfo(accountId, balance) {
          if (!accountId) {
            isLoggedIn = false;
            document.getElementById("connect-wallet-btn").style.display =
              "block";
            document.getElementById("disconnect-wallet-btn").style.display =
              "none";
            document.getElementById("account-id").textContent = ``;
            document.getElementById("crosshair").style.display = "none";  
          // Show welcome message
          document.getElementById("welcome-msg").style.display = "block";

          document.getElementById("connect-wallet-btn").addEventListener("click", () => {
            document.getElementById("welcome-msg").style.display = "none"; // Hide immediately
            setTimeout(() => {
                if (!isLoggedIn) { // Only show if not logged in
                    document.getElementById("welcome-msg").style.display = "block"; // Show again after 30 seconds
                }
            }, 30000);
        });

            return;
          }

          isLoggedIn = true;
                                       // Show welcome message
  document.getElementById("welcome-msg").style.display = "none";

          document.getElementById(
            "account-id"
          ).textContent = `Acc: ${accountId}`;
          document.getElementById("connect-wallet-btn").style.display = "none";
          document.getElementById("disconnect-wallet-btn").style.display =
            "block";
          document.getElementById("crosshair").style.display = "block";
          globalAccountId = accountId; // Assign accountId to the external variable
                      // Call loadProfileObject after globalAccountId is set
                      const profileObjectUrl = await loadProfileObject();

                      const profileObjectCrosshair = await loadProfileCrosshair();

                      const profileObjectSettings = await loadProfileSettings();

                      const modelUrl = profileObjectSettings.length > 0 && profileObjectSettings[0].urls && profileObjectSettings[0].urls.length > 0 
                      ? profileObjectSettings[0].urls[0] 
                      : defaultModelUrl; // Use default model URL if no valid URL is found

              await loadUfoModel(modelUrl); // Load the model using the determined URL
               confirmNFTFunction(accountId); // Call confirmNFTFunction after the process is complete

              document.getElementById("submit-button").addEventListener("click", debounce(async () => {
              await confirmNFTFunction(accountId);
            }, 250));
               await extractAccountId();       
        }
        loader.updateProgress();


        document.getElementById("load-msgs-from-ids-button").addEventListener("click", async () => {
    const ids = document.getElementById("load-msgs-from-ids").value.toLowerCase();
    const idsArray = ids.split(",").map(id => id.trim()).filter(id => id.length > 0); // Trim whitespace and filter out empty strings
 
        // New logic to process idsArray
    idsArray.forEach(id => {
        if (!id.startsWith("0.0.")) {
            const domainEntry = loadedDomains.find(domain => domain.domain === id); // Assuming loadedDomains is an array of objects with an 'id' property
            idsArray.splice(idsArray.indexOf(id), 1); // Remove the id from idsArray
            if (domainEntry) {
                idsArray.push(domainEntry.lastMessage.topic); // Add the domain entry to idsArray
            } 
        }
    });

    await handleAllMessages();

    // Filter geojson.features based on the specified payers
    const filteredFeatures = geojson.features.filter(feature => {
        const match = idsArray.includes(feature.payer);
        return match;
    });

    const filteredPolygons = polygons.filter(polygon => {
        const match = idsArray.includes(polygon.payer);
        return match;
    });

    console.log(filteredFeatures, 'filteredFeatures');
    console.log(filteredPolygons, 'filteredPolygons');

        // Clear existing features and polygons
        geojson.features = filteredFeatures;
        polygons.length = 0; // Clear existing polygons
        polygons.push(...filteredPolygons); // Add filtered polygons



        setTimeout(() => {
        existingMarkers.forEach(marker => marker.remove());
        existingMarkers = [];
      }, 250);

        // Remove existing polygon layers
        map.getStyle().layers.forEach(layer => {
          if (layer.id.includes('-layer')) {
            map.removeLayer(layer.id);
          }
        });

        // Remove existing polygon sources
        const sourceIds = Object.keys(map.getStyle().sources);
        sourceIds.forEach(sourceId => {
          if (sourceId.includes('-source')) {
            map.removeSource(sourceId);
          }
        });


        // Only load features if there are any
        if (geojson.features.length > 0) {
            index.load(geojson.features);
            updateClusters(); // Assuming you have a function to update clusters
        }
        if (polygons.length > 0) {
            // Add new polygons
            polygons.forEach(polygon => {
                addPolygonWithImageFill(map, polygon);
            });
        }
      });
      loader.updateProgress();

        document.getElementById("button4").addEventListener("click", async () => {


  const domain = document.getElementById("toolbar-input").value;
  const domainObject = loadedDomains.find(d => d.domain === domain);

  if (domainObject) {
    const currentTime = Date.now() / 1000; // Get current time in seconds

    const timeLeftInSeconds = domainObject.addedTime - currentTime;

    // Calculate days, hours, minutes, and seconds
    const days = Math.floor(timeLeftInSeconds / (24 * 3600));
    const hours = Math.floor((timeLeftInSeconds % (24 * 3600)) / 3600);
    const minutes = Math.floor((timeLeftInSeconds % 3600) / 60);
    const seconds = Math.floor(timeLeftInSeconds % 60);

    const formattedTimeLeft = `${days}d ${hours}h ${minutes}m ${seconds}s`;

    document.getElementById("domain-time-left").textContent = `Time left: ${formattedTimeLeft}`;
  } else {
    console.warn("Domain not found in loadedDomains.");
    document.getElementById("domain-time-left").textContent = 'no one uses this domain';
  }
});

document.getElementById('go-to-top-msgs').addEventListener('click', function() {
    // Get the container element
    const container = document.getElementById('topic-chat-container');
    
    // Scroll to the top of the container
    container.scrollTop = 0;
  });
        

  let storedMessages = []; // Declare an external array to store messages

document.getElementById("load-msgs-from").addEventListener("click", async () => {
  try {
    let userInput = document.getElementById("topic-chat-topic-id").value.toLowerCase();
    let domainEntry = loadedDomains.find(entry => entry.domain === userInput);
    let topicId;

    if (domainEntry && domainEntry.lastMessage) {
      topicId = domainEntry.lastMessage.topic;
    } else {
      topicId = userInput;
    }

    const topicInfo = await sdk.getTopicInfo(topicId);
          const topicAdmin = [];
          const memo = topicInfo.memo;

          // Split the memo by commas
          const parts = memo.split(',');

          // Iterate over each part
          parts.forEach(part => {
            // Check if the part starts with "0.0."
            if (part.startsWith("0.0.")) {
              // Add it to the topicAdmin array
              topicAdmin.push(part);
            }
          });

    const result = await window.HashinalsWalletConnectSDK.getMessages(topicId);

    if (!result || !Array.isArray(result.messages)) {
      console.log("No messages found or result is not an array.");
      return [];
    }

    const profilePictures = await loadProfilePicture(); // Load profile pictures
    const usernames = await loadUsername(); // Load usernames


    let allMessages = ''; // Initialize an empty string to hold all messages

    let previousPayer = null; // Track the previous payer

    const topicActions = new Map();

    const loadedNFTsForTopicChat = [];


    for (let index = 0; index < result.messages.length; index++) {
      const message = result.messages[index];
      try {
        let parsedMessage = message;
        if (typeof message === 'string') {
          parsedMessage = JSON.parse(message);
        }
        const timestamp = message.timestamp || Date.now(); // Use message timestamp or current time

        if (parsedMessage.addTopicChatNFT && (topicAdmin.length === 0 || topicAdmin.includes(message.payer))) {
        const nfts = parsedMessage.addTopicChatNFT.split(',').map(nft => nft.trim());
        nfts.forEach(nft => {
          if (nft.startsWith("0.0.") && !loadedNFTsForTopicChat.includes(nft)) { // Check if NFT starts with "0.0."
            loadedNFTsForTopicChat.push(nft);
          }
        });
      }

      if (parsedMessage.removeTopicChatNFT && (topicAdmin.length === 0 || topicAdmin.includes(message.payer))) {
        const nft = parsedMessage.removeTopicChatNFT.trim();
        if (nft.startsWith("0.0.")) { // Check if NFT starts with "0.0."
          const index = loadedNFTsForTopicChat.indexOf(nft);
          if (index !== -1) {
            loadedNFTsForTopicChat.splice(index, 1);
          }
        }
      }
      } catch (messageError) {
        console.error(`Error processing message ${index}:`, messageError);
      }
    }


    if (loadedNFTsForTopicChat.length > 0) {
  console.log("loadedNFTsForTopicChat", loadedNFTsForTopicChat);
}

// Process messages
for (let index = 0; index < result.messages.length; index++) {
  const message = result.messages[index];
  try {
    let parsedMessage = message;
    if (typeof message === 'string') {
      parsedMessage = JSON.parse(message);
    }

    const payer = parsedMessage.payer || 'Unknown';

    // Check if the payer owns any NFT from loadedNFTsForTopicChat
    let payerHasNFT = false;
    if (loadedNFTsForTopicChat.length > 0) {
      for (const item of loadedNFTsForTopicChat) {
        const checkIfUserHasNFT = await sdk.getAccountNFTs(payer, item);
        if (checkIfUserHasNFT.length > 0) {
          payerHasNFT = true;
          break;
        }
      }
    } else {
      payerHasNFT = true; // If no NFTs to check, allow all messages
    }

    if (payerHasNFT && parsedMessage.userMessage) {
      const userMessage = parsedMessage.userMessage;

const payerImage = profilePictures[payer]?.url || 'https://kiloscribe.com/api/inscription-cdn/0.0.4819119';

// Function to validate URL
function isValidUrl(string) {
  try {
    new URL(string);
    return true;
  } catch (_) {
    return false;  
  }
}

// Check if payerImage is valid, if not use fallback
const validPayerImage = isValidUrl(payerImage) ? payerImage : 'https://kiloscribe.com/api/inscription-cdn/0.0.4819119';

      
      const username = usernames[payer]?.username || '';
      const timestamp = new Date(parsedMessage.created).toLocaleString('en-US', {
  hour12: false,
  year: 'numeric',
  month: '2-digit',
  day: '2-digit',
  hour: '2-digit',
  minute: '2-digit',
  second: '2-digit'
}); // Format as MM/DD/YYYY HH:MM:SS

      // Store the message in the external array
      storedMessages.push(parsedMessage);

      // Only show the payer and image if it's different from the previous one
      if (payer !== previousPayer) {
        allMessages += `<div style="display: flex; align-items: center; font-size: 1em; margin-top: 1em;">
                          <img src="${validPayerImage}" alt="Payer Image" style="width: 2em; height: 2em; margin-right: 0.5em; border-radius: 1em;">
                          <div style="display: flex; flex-direction: column; justify-content: center;">
                            <div>${payer}${username ? ` ${username}` : ''}&nbsp;&nbsp;<span style="font-size: 0.8em; color: gray;">${timestamp}</span></div>
                            <div>${userMessage}</div>
                          </div>
                        </div><br>`;
      } else {
        allMessages += `<div style="display: flex; align-items: center; font-size: 1em; margin-left: 2.5em; margin-top: -1.25em;">
                          <div>${userMessage}</div>
                        </div><br>`;
      }
      previousPayer = payer; // Update the previous payer
    } else {
      console.warn(`Message ${index} is missing payer or data.`);
    }
  } catch (messageError) {
    console.error(`Error processing message ${index}:`, messageError);
  }
}

const chatContainer = document.getElementById('topic-chat-container');
  let startY, scrollTop;

  chatContainer.addEventListener('touchstart', (e) => {
    startY = e.touches[0].pageY - chatContainer.offsetTop;
    scrollTop = chatContainer.scrollTop;
  });

  chatContainer.addEventListener('touchmove', (e) => {
    const y = e.touches[0].pageY - chatContainer.offsetTop;
    const walk = (y - startY) * 2; // Adjust the multiplier for sensitivity
    chatContainer.scrollTop = scrollTop - walk;
    e.preventDefault(); // Prevent default touch behavior
  });

  const messagesContainer = document.getElementById('messages-from-topic-chat');

messagesContainer.addEventListener('touchstart', (e) => {
  startY = e.touches[0].pageY - messagesContainer.offsetTop;
  scrollTop = messagesContainer.scrollTop;
  e.stopPropagation(); // Stop the event from bubbling up
});

messagesContainer.addEventListener('touchmove', (e) => {
  const y = e.touches[0].pageY - messagesContainer.offsetTop;
  const walk = (y - startY) * 2; // Adjust the multiplier for sensitivity
  messagesContainer.scrollTop = scrollTop - walk;
  e.preventDefault(); // Prevent default touch behavior
  e.stopPropagation(); // Stop the event from bubbling up
});


const messageContainer = document.getElementById("messages-from-topic-chat");
messageContainer.innerHTML = allMessages;
adjustTextareaHeight(messageContainer);

// Scroll to the bottom of the message container
messageContainer.scrollTop = messageContainer.scrollHeight;

  } catch (error) {
    console.error("Error setting rules:", error);
  }
});

document.getElementById("topic-msgs-filter").addEventListener("click", async () => {
  const fromDateInput = document.getElementById("from-mmddyyyy").value;
  const toDateInput = document.getElementById("to-mmddyyyy").value;

  if (!fromDateInput || !toDateInput) {
    console.error("Please provide both from and to dates.");
    return;
  }
  
  const profilePictures = await loadProfilePicture(); // Load profile pictures
  const usernames = await loadUsername(); // Load usernames

  const fromDate = new Date(fromDateInput.slice(4, 8), fromDateInput.slice(0, 2) - 1, fromDateInput.slice(2, 4));
  const toDate = new Date(toDateInput.slice(4, 8), toDateInput.slice(0, 2) - 1, toDateInput.slice(2, 4));

  console.log("fromDate", fromDate);
  console.log("toDate", toDate);
  
  // Adjust toDate to include the entire day
  toDate.setHours(23, 59, 59, 999);

  const filteredMessages = storedMessages.filter(message => {
    const messageDate = new Date(message.created); // Parse the created date string
    return messageDate >= fromDate && messageDate <= toDate;
  });

  let filteredMessagesHtml = '';
  let previousPayer = null;
  

  filteredMessages.forEach(parsedMessage => {
    const userMessage = parsedMessage.userMessage;
    const payer = parsedMessage.payer || 'Unknown';
    const payerImage = profilePictures[payer]?.url || 'https://kiloscribe.com/api/inscription-cdn/0.0.4819119';

// Function to validate URL
function isValidUrl(string) {
  try {
    new URL(string);
    return true;
  } catch (_) {
    return false;  
  }
}

// Check if payerImage is valid, if not use fallback
const validPayerImage = isValidUrl(payerImage) ? payerImage : 'https://kiloscribe.com/api/inscription-cdn/0.0.4819119';
    const username = usernames[payer]?.username || '';
    const timestamp = new Date(parsedMessage.created).toLocaleString('en-US', {
  hour12: false,
  year: 'numeric',
  month: '2-digit',
  day: '2-digit',
  hour: '2-digit',
  minute: '2-digit',
  second: '2-digit'
}); // Format as MM/DD/YYYY HH:MM:SS

    if (payer !== previousPayer) {
      filteredMessagesHtml +=  `<div style="display: flex; align-items: center; font-size: 1em; margin-top: 1em;">
                              <img src="${validPayerImage}" alt="Payer Image" style="width: 2em; height: 2em; margin-right: 0.5em; border-radius: 1em;">
                              <div style="display: flex; flex-direction: column; justify-content: center;">
                                <div>${payer}${username ? ` ${username}` : ''}&nbsp;&nbsp;<span style="font-size: 0.8em; color: gray;">${timestamp}</span></div>
                                <div>${userMessage}</div>
                              </div>
                            </div><br>`;
    } else {
      filteredMessagesHtml += `<div style="display: flex; align-items: center; font-size: 1em; margin-left: 2.5em; margin-top: -1.25em;">
                              <div>${userMessage}</div>
                            </div><br>`;
    }

    previousPayer = payer;
  });

  const messageContainer = document.getElementById("messages-from-topic-chat");
  messageContainer.innerHTML = filteredMessagesHtml;
  adjustTextareaHeight(messageContainer);
  messageContainer.scrollTop = messageContainer.scrollHeight;

});

document.getElementById("topic-msgs-filter-time").addEventListener("click", async () => {
  const fromDateInput = document.getElementById("from-mmddyyyy").value;
  const toDateInput = document.getElementById("to-mmddyyyy").value;
  const fromTimeInput = document.getElementById("from-hhmmss").value;
  const toTimeInput = document.getElementById("to-hhmmss").value;

  if (!fromDateInput || !toDateInput || !fromTimeInput || !toTimeInput) {
    console.error("Please provide both from and to dates and times.");
    return;
  }

  const profilePictures = await loadProfilePicture(); // Load profile pictures
  const usernames = await loadUsername(); // Load usernames

  const fromDate = new Date(
    fromDateInput.slice(4, 8), 
    fromDateInput.slice(0, 2) - 1, 
    fromDateInput.slice(2, 4),
    fromTimeInput.slice(0, 2), // Hours
    fromTimeInput.slice(2, 4), // Minutes
    fromTimeInput.slice(4, 6)  // Seconds
  );

  const toDate = new Date(
    toDateInput.slice(4, 8), 
    toDateInput.slice(0, 2) - 1, 
    toDateInput.slice(2, 4),
    toTimeInput.slice(0, 2), // Hours
    toTimeInput.slice(2, 4), // Minutes
    toTimeInput.slice(4, 6)  // Seconds
  );

  console.log("fromDate", fromDate);
  console.log("toDate", toDate);

  const filteredMessages = storedMessages.filter(message => {
    const messageDate = new Date(message.created); // Parse the created date string
    return messageDate >= fromDate && messageDate <= toDate;
  });

  let filteredMessagesHtml = '';
  let previousPayer = null;

  filteredMessages.forEach(parsedMessage => {
    const userMessage = parsedMessage.userMessage;
    const payer = parsedMessage.payer || 'Unknown';
    const payerImage = profilePictures[payer]?.url || 'https://kiloscribe.com/api/inscription-cdn/0.0.4819119';

// Function to validate URL
function isValidUrl(string) {
  try {
    new URL(string);
    return true;
  } catch (_) {
    return false;  
  }
}

// Check if payerImage is valid, if not use fallback
const validPayerImage = isValidUrl(payerImage) ? payerImage : 'https://kiloscribe.com/api/inscription-cdn/0.0.4819119';
    const username = usernames[payer]?.username || '';
    const timestamp = new Date(parsedMessage.created).toLocaleString('en-US', {
  hour12: false,
  year: 'numeric',
  month: '2-digit',
  day: '2-digit',
  hour: '2-digit',
  minute: '2-digit',
  second: '2-digit'
}); // Format as MM/DD/YYYY HH:MM:SS

    if (payer !== previousPayer) {
      filteredMessagesHtml += `<div style="display: flex; align-items: center; font-size: 1em; margin-top: 1em;">
                                <img src="${validPayerImage}" alt="Payer Image" style="width: 2em; height: 2em; margin-right: 0.5em; border-radius: 1em;">
                                <div style="display: flex; flex-direction: column; justify-content: center;">
                                  <div>${payer}${username ? ` ${username}` : ''}&nbsp;&nbsp;<span style="font-size: 0.8em; color: gray;">${timestamp}</span></div>
                                  <div>${userMessage}</div>
                                </div>
                              </div><br>`;
    } else {
      filteredMessagesHtml += `<div style="display: flex; align-items: center; font-size: 1em; margin-left: 2.5em; margin-top: -1.25em;" >
                                <div>${userMessage}</div>
                              </div><br>`;
    }

    previousPayer = payer;
  });

  const messageContainer = document.getElementById("messages-from-topic-chat");
  messageContainer.innerHTML = filteredMessagesHtml;
  adjustTextareaHeight(messageContainer);
  messageContainer.scrollTop = messageContainer.scrollHeight;

});



        
        let loadedDomains = [
        ];


async function loadDomains() {
  try {
    const topicId = "0.0.9606779"; 

    const result = await window.HashinalsWalletConnectSDK.getMessages(topicId);

    if (!result || !Array.isArray(result.messages)) {
      console.log("No messages found or result is not an array.");
      return [];
    }

    const domainsMap = new Map();

    for (let index = 0; index < result.messages.length; index++) {
      const message = result.messages[index];
      try {
        let parsedMessage = message;
        if (typeof message === 'string') {
          parsedMessage = JSON.parse(message);
        }

        if (parsedMessage.payer && parsedMessage.domain) {
          const domain = parsedMessage.domain;
          if (!domainsMap.has(domain)) {
            domainsMap.set(domain, []);
          }
          domainsMap.get(domain).push({
            topic: parsedMessage.topic,
            domain: domain,
            payer: parsedMessage.payer,
            timestamp: parsedMessage.consensus_timestamp // or parsedMessage.timestamp
          });
        } else {
          console.warn(`Message ${index} is missing payer or data.`);
        }
      } catch (messageError) {
        console.error(`Error processing message ${index}:`, messageError);
      }
    }

    const SECONDS_TO_ADD = 2419200; // 2,419,200 seconds
    const currentTime = Date.now() / 1000; // Current time in seconds
    let timeleft = 0;
    let firstValidLastMessage = null;
    let addedTime = null;


    const domainsArray = Array.from(domainsMap.entries()).map(([domain, messages]) => {

  // Sort all messages for the domain by timestamp
  messages.sort((a, b) => parseFloat(a.timestamp) - parseFloat(b.timestamp));

  let addedTime = parseFloat(messages[0].timestamp);
  let firstValidPayer = null;

  // Find the first valid payer
  for (let i = 0; i < messages.length; i++) {
    if (parseFloat(messages[i].timestamp) <= addedTime) {
      firstValidPayer = messages[i].payer;
      break;
    }
  }

  // Extend addedTime for the first valid payer
  if (firstValidPayer) {
    for (let i = 0; i < messages.length; i++) {
      if (messages[i].payer === firstValidPayer && parseFloat(messages[i].timestamp) <= addedTime) {
        addedTime += SECONDS_TO_ADD;
      }
    }
  }

  // Filter messages to only include those from the first valid payer
  const validPayerMessages = messages.filter(message => message.payer === firstValidPayer);

  // Get the last message from the valid payer
  const lastMessage = validPayerMessages[validPayerMessages.length - 1];


  return {
    domain,
    lastMessage,
    addedTime
  };
});

    return domainsArray;

  } catch (error) {
    console.error("Error in loadDomains:", error);
    return [];
  }
}

loadDomains().then(domains => {
  loadedDomains = domains.filter(domain => !domain.domain.includes("0.0."));
});


        document.getElementById("copy-coordinates").addEventListener("click", () => {
    // Get the current center of the map
    const center = map.getCenter();
    const coordinates = `${center.lng.toFixed(5)},${center.lat.toFixed(5)}`;
  
    // Copy the coordinates to the clipboard
    navigator.clipboard.writeText(coordinates).then(() => {
    }).catch(err => {
      console.error("Failed to copy coordinates:", err);
    });
  });
  loader.updateProgress();
        
// Define a default model URL
const defaultModelUrl = 'https://kiloscribe.com/api/inscription-cdn/0.0.8392276?network=mainnet'; // Replace with your actual default model URL
await loadUfoModel(defaultModelUrl);
let BetaNFTScaleFactor = 1;

        async function connectWallet() {
          try {
            const { balance, accountId } = await sdk.connectWallet(
              PROJECT_ID,
              APP_METADATA
            );
            console.log("account info is", accountId, balance);
            updateAccountInfo(accountId, balance);
          } catch (error) {
            console.error("Failed to connect wallet:", error);
          }
        }

        async function disconnectWallet() {
          try {
            await sdk.disconnectWallet(PROJECT_ID, APP_METADATA);
            updateAccountInfo(undefined);
          } catch (error) {
            console.error("Failed to connect wallet:", error);
          }
        }

        async function initAccount() {
          const accountResponse = await sdk.initAccount(
            PROJECT_ID,
            APP_METADATA
          );

          if (accountResponse && accountResponse.accountId) {
            updateAccountInfo(
              accountResponse.accountId,
              accountResponse.balance
            );


          } else {
            console.log("Account ID not found in response");
          }
        }

 
        initAccount()
        updateAccountInfo();

        document
          .getElementById("connect-wallet-btn")
          .addEventListener("click", connectWallet);
        document
          .getElementById("disconnect-wallet-btn")
          .addEventListener("click", disconnectWallet);


          async function extractAccountId() {
            const thisAccountId = globalAccountId;
            console.log("globalAccountId is", thisAccountId)
            return thisAccountId;
          }
         

                // Create a new topic
                document
  .getElementById("submit-button-column5")
  .addEventListener("click", async () => {
    try {
      const memo = document.getElementById("input-field-5-1").value || '';
      const adminKey = document.getElementById("input-field-5-2").value;
      // const fee = document.getElementById("input-field-5-3").value;
      // const tokenId = document.getElementById("input-field-5-4").value;
      // const royaltyAccount = document.getElementById("input-field-5-5").value;

      if ((memo && !adminKey) || (!memo && adminKey)) {
        console.error("Both memo and adminKey must be provided together.");
        return;
      }

      let createdTopicId;
      if (memo && adminKey) {
        createdTopicId = await window.HashinalsWalletConnectSDK.createTopic(memo, adminKey);
      } else {
        createdTopicId = await window.HashinalsWalletConnectSDK.createTopic();
      }

      console.log("createdTopicId is", createdTopicId);


      document.getElementById("input-field-5").value = createdTopicId;
      document.getElementById("input-field-2-0").value = createdTopicId;
      document.getElementById("input-field-3-0").value = createdTopicId;
      document.getElementById("input-field").value = createdTopicId;
    } catch (error) {
      console.error("Error creating topic:", error);
    }
  });

          function adjustTextareaHeight(textarea) 
          {
          textarea.style.height = ''; // Reset the height
          textarea.style.height = textarea.scrollHeight + 10 + 'px'; // Set it to the scroll height
          }

          document.getElementById("generate-private-and-public-key").addEventListener("click", async () => {
          try {
            const { privateKey, publicKey } = await sdk.generatePrivateAndPublicKey();

            const privateKeyTextarea = document.getElementById("generated-private-key");
            const publicKeyTextarea = document.getElementById("generated-public-key");

            privateKeyTextarea.value = privateKey;
            publicKeyTextarea.value = publicKey;

            // Adjust the height of the textareas
            adjustTextareaHeight(privateKeyTextarea);
            adjustTextareaHeight(publicKeyTextarea);

          } catch (error) {
            console.error("Error creating topic:", error);
          }
        });


document.getElementById("submit-button-change-memo").addEventListener("click", async () => {
  try {
              let userInput = document.getElementById("input-field-topic-id").value.toLowerCase();
              let domainEntry = loadedDomains.find(entry => entry.domain === userInput);
              let topicId;

              if (domainEntry && domainEntry.lastMessage) {
                topicId = domainEntry.lastMessage.topic;
              } else {
                topicId = userInput;
              }
              const memo =document.getElementById("input-field-memo").value || '';

              let adminKey = document.getElementById("input-field-admin-key").value;

              const realfee = document.getElementById("input-field-fee").value;
      const tokenId = document.getElementById("input-field-fee-token").value;
      const royaltyAccount = document.getElementById("input-field-royal-acc").value;
      const feeScheduleKey = document.getElementById("input-field-admin-key").value;

      const fee = realfee * 1000000

      let customFees = [];

      let createdTopicId;

      if (fee && tokenId && royaltyAccount) {
        // If all fields are provided, use all parameters
        customFees.push({
          denominatingTokenId: tokenId,
          amount: fee,
          collectorAccountId: royaltyAccount
        });
        const topic = topicId;
        const changeMemo =
        await window.HashinalsWalletConnectSDK.updateTopic(topic , memo, adminKey, customFees, feeScheduleKey);
      } else {
        const topic = topicId;
        const changeMemo =
        await window.HashinalsWalletConnectSDK.updateTopic(topic , memo, adminKey);
      }


  } catch (error) {
    console.error("Error creating topic:", error);
  }
});


          

          

          async function loadProfilePicture() {
            const topicId = "0.0.9609881";
            const accountUrls = {}; // Dictionary to store account IDs and their URLs

            try {
              const result = await window.HashinalsWalletConnectSDK.getMessages(topicId);

              // Check if result exists and has messages
              if (!result || !Array.isArray(result.messages)) {
                console.log("No profile pictures found, using defaults");
                return {};
              }

              // Process all messages to build the accountUrls dictionary
              result.messages.forEach(message => {
                if (message.payer && message.data && message.data.urls && message.data.urls.length > 0) {
                  // Store or update the URL for this account
                  accountUrls[message.payer] = {
                    url: message.data.urls[0],
                    timestamp: message.timestamp
                  };
                }
              });

      
              return accountUrls;

            } catch (error) {
              console.log("Error in loadProfilePicture:", error);
              return {}; // Return empty object instead of throwing error
            }
          }
          loadProfilePicture();
          loader.updateProgress();

          async function loadUsername() {
            const topicId = "0.0.9609904";
            const accountUsernames = {}; // Dictionary to store account IDs and their usernames

            try {
              const result = await window.HashinalsWalletConnectSDK.getMessages(topicId);
           

              // Check if result exists and has messages
              if (!result || !Array.isArray(result.messages)) {
                console.log("No usernames found, using defaults");
                return {};
              }

              // Process all messages to build the accountUsernames dictionary
              result.messages.forEach(message => {
                if (message.payer && message.data) {
                  // Store or update the username for this account
                  accountUsernames[message.payer] = {
                    username: message.data.username,
                    timestamp: message.timestamp
                  };
                }
              });

    
              return accountUsernames;

            } catch (error) {
              console.log("Error in loadUsername:", error);
              return {}; // Return empty object instead of throwing error
            }
          }

          const geojson = {
                type: "FeatureCollection",
                features: []
                };

          const polygons = [];

          const loadedNFTsForModel = [];
          const loadedNFTScaleForModel = [];
          let hasRulesForModelNFT = false;

          function updateRulesForModelNFTState() {
  if (loadedNFTsForModel.length > 0) {
    hasRulesForModelNFT = true;
  } else {
    hasRulesForModelNFT = false;
  }
}


let globalLoadedTopicIdsWithNames = [];


  async function handleAllMessages() {
  try {
    const profilePics = await loadProfilePicture();
    const usernames = await loadUsername();
// Get the user input
let userInput = document.getElementById("input-field").value.toLowerCase();
let domainEntry = loadedDomains.find(entry => entry.domain === userInput);
let topicId;

if (domainEntry && domainEntry.lastMessage) {
  topicId = domainEntry.lastMessage.topic;
} else {
  topicId = userInput || "0.0.9609912";
}
    const result = await window.HashinalsWalletConnectSDK.getMessages(topicId);

    globalLoadedTopicIdsWithNames = [];
    let addedTopics = [];
    let removedTopics = [];
    let loadedTopicsIds = [];

    const loaded_text_area = document.getElementById("loaded-topics");
  loaded_text_area.value = ''; // Clear the current value

    let hasMoreThanOneTopic = false;

    geojson.features = [];
    polygons.length = 0;

    // Remove existing markers
    existingMarkers.forEach(marker => marker.remove());
    existingMarkers = [];

    // Remove existing polygon layers
    map.getStyle().layers.forEach(layer => {
      if (layer.id.includes('-layer')) {
        map.removeLayer(layer.id);
      }
    });

    // Remove existing polygon sources
    const sourceIds = Object.keys(map.getStyle().sources);
    sourceIds.forEach(sourceId => {
      if (sourceId.includes('-source')) {
        map.removeSource(sourceId);
      }
    });

    const topicInfo = await sdk.getTopicInfo(topicId);
          const topicAdmin = [];
          const memo = topicInfo.memo;

          // Split the memo by commas
          const parts = memo.split(',');

          // Iterate over each part
          parts.forEach(part => {
            // Check if the part starts with "0.0."
            if (part.startsWith("0.0.")) {
              // Add it to the topicAdmin array
              topicAdmin.push(part);
              hasRules = true;
            }
          });

    // Initialize a map to track the latest action for each topic
    const topicActions = new Map();

    for (let index = 0; index < result.messages.length; index++) {
      const message = result.messages[index];
      try {
        let parsedMessage = message;
        if (typeof message === 'string') {
          parsedMessage = JSON.parse(message);
        }
        const timestamp = message.timestamp || Date.now(); // Use message timestamp or current time

        if (parsedMessage.addTopic && parsedMessage.addTopic.addTopic && (topicAdmin.length === 0 || topicAdmin.includes(message.payer))) {
          hasMoreThanOneTopic = true;
          const topics = typeof parsedMessage.addTopic.addTopic === 'string' 
            ? parsedMessage.addTopic.addTopic.split(',') 
            : [];
          topics.forEach(topic => {
            topicActions.set(topic, { action: 'add', timestamp });
          });
        }

        if (parsedMessage.removeTopic && parsedMessage.removeTopic.removeTopic && (topicAdmin.length === 0 || topicAdmin.includes(message.payer))) {
          hasMoreThanOneTopic = true;
          const topics = typeof parsedMessage.removeTopic.removeTopic === 'string' 
            ? parsedMessage.removeTopic.removeTopic.split(',') 
            : [];
          topics.forEach(topic => {
            topicActions.set(topic, { action: 'remove', timestamp });
          });
        }
      } catch (messageError) {
        console.error(`Error processing message ${index}:`, messageError);
      }
    }

    // Determine the final list of topics based on the latest action
    loadedTopicsIds = Array.from(topicActions.entries())
      .filter(([topic, { action }]) => action === 'add' && topic.startsWith('0.0.'))
      .map(([topic]) => topic);

      const loadedTopicIdsWithNames = [];


// Load and process messages from each topic in loadedTopicsIds
for (const topicId of loadedTopicsIds) {
  const { topicGeojsonFeatures, topicPolygons, loadedTopicName } = await processTopicMessages(topicId); // Ensure this is awaited if it's async

  // Update markers/clusters
  if (geojson.features.length > 0) {
    index.load(geojson.features);
    updateClusters();
  }
  // Add new polygons
  polygons.forEach(polygon => {
    addPolygonWithImageFill(map, polygon);
  });


    if (loadedTopicName !== undefined) { // Only skip if loadedTopicName is undefined
      const topicNamePart = loadedTopicName ? `-${loadedTopicName}` : '';
      loadedTopicIdsWithNames.push(`${topicId}${topicNamePart}`);
    }
}

globalLoadedTopicIdsWithNames = loadedTopicIdsWithNames;


globalLoadedTopicIdsWithNames.sort((a, b) => {
  const idA = parseFloat(a.split('-')[0].replace('0.0.', ''));
  const idB = parseFloat(b.split('-')[0].replace('0.0.', ''));
  return idA - idB;
});

  loaded_text_area.value = globalLoadedTopicIdsWithNames.join('\n'); // Update with new values
  adjustTextareaHeight(loaded_text_area); // Adjust height after loading

return loadedTopicIdsWithNames; // Return the loadedTopicsIds array



    
    
    
  } catch (error) {
    console.error("Error processing topic messages:", error);
  }
};
loader.updateProgress();





// Sort the array by scale in descending order
loadedNFTScaleForModel.sort((a, b) => b.scale - a.scale);
let scaleForModel = 1;
let finalScaleForModel = 1;



async function confirmNFTFunction(accountId) {
  let tokenIdForModel = "0.0.9605689";
  let tokenIDForBeta = "0.0.9606654";
  let userInput = document.getElementById("input-field").value.toLowerCase();
let domainEntry = loadedDomains.find(entry => entry.domain === userInput);
let topicId;

if (domainEntry && domainEntry.lastMessage) {
  topicId = domainEntry.lastMessage.topic;
} else {
  topicId = userInput || "0.0.9609912";
}
  await handleAllMessages();

  // Reset any stateful variables
  loadedNFTsForModel.length = 0; // Clear the array if it's used to store data
  hasRulesForModelNFT = false; // Reset the flag if it's used to track state


  const NFTForModel = await sdk.getAccountNFTs(accountId, tokenIdForModel);
  const NFTForBeta = await sdk.getAccountNFTs(accountId, tokenIDForBeta);

  if (NFTForBeta.length > 0) {
    BetaNFTScaleFactor = 1.5;
    finalScaleForModel = BetaNFTScaleFactor*scaleForModel;
  } else {
    BetaNFTScaleFactor = 1; // Set to 1 if no beta NFTs
  }



  if (loadedNFTScaleForModel.length > 0) {
    for (const item of loadedNFTScaleForModel) {
      const checkIfUserHasNFT = await sdk.getAccountNFTs(accountId, item.NFT);
      if (checkIfUserHasNFT.length > 0) {
        scaleForModel = item.scale;
        finalScaleForModel = BetaNFTScaleFactor*scaleForModel;
        break;
      }
      else {
        scaleForModel = 1;
      }
    }
  }
 

  if (NFTForModel.length > 0) {
    try {
      if (hasRulesForModelNFT === true) {
        for (const nft of loadedNFTsForModel) {
          const checkIfUserHasNFT = await sdk.getAccountNFTs(accountId, nft);
          if (checkIfUserHasNFT.length > 0) {
            await someFunction(accountId, topicId);
            return true;
          }
        }
        return false;
      }

      if (hasRulesForModelNFT === false) {
        await someFunction(accountId, topicId);
      }

    } catch (error) {
    }
  } else {
    return false;
  }
}








const renderer = new THREE.WebGLRenderer({ alpha: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
document
  .getElementById("three-container")
  .appendChild(renderer.domElement);

const camera = new THREE.PerspectiveCamera(
  45,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);

function createStars() {
  const starsGeometry = new THREE.BufferGeometry();
  const starCount = 25000;
  const positions = new Float32Array(starCount * 3);
  const spawnRadius = 10;

  for (let i = 0; i < starCount; i++) {
    const i3 = i * 3;
    positions[i3] = (Math.random() - 0.5) * 2000 + spawnRadius;
    positions[i3 + 1] = (Math.random() - 0.5) * 2000 + spawnRadius;
    positions[i3 + 2] = (Math.random() - 0.5) * 2000 + spawnRadius;
  }

  starsGeometry.setAttribute(
    "position",
    new THREE.BufferAttribute(positions, 3)
  );
  const starsMaterial = new THREE.PointsMaterial({
    color: 0xffffff,
    size: 0.5,
    sizeAttenuation: true,
  });

  const stars = new THREE.Points(starsGeometry, starsMaterial);
  scene.add(stars);
  return stars;
}

const stars = createStars();


const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
scene.add(ambientLight);

const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
directionalLight.position.set(5, 5, 5);
scene.add(directionalLight);

camera.position.z = 10;

const randomLatitude = (Math.random() * 180) - 90; // Random latitude between -90 and 90
const randomLongitude = (Math.random() * 360) - 180; // Random longitude between -180 and 180

const map = new maplibregl.Map({
  container: "map",
  style: "https://tiles.openfreemap.org/styles/liberty",
  center: [randomLongitude, randomLatitude], // Use random coordinates
  zoom: 1.5,
  pitch: 0,
  bearing: 0,
  maxPitch: 75,
  maxZoom: 19,
  antialias: true,
  projection: {
    name: "globe",
  },
});

// map.dragPan.disable();
// map.scrollZoom.disable();
// map.boxZoom.disable();
// map.doubleClickZoom.disable();
// map.touchZoomRotate.disable();
// map.dragRotate.disable();


const keys = {
  w: false,
  a: false,
  s: false,
  d: false,
  q: false,
  e: false,
  space: false,
  shift: false,
  r: false,
  f: false,
};

const MOVE_SPEED = 0.5;
const BUTTON_PAN_SPEED = 6;
const BUTTON_ZOOM_SPEED = 0.05;

const speedSlider = document.getElementById("speed-slider");

function getSpeedMultiplier() {
  return parseFloat(speedSlider.value);
}

function checkToolbarStatus() {
  const toolbars = [
    document.getElementById("load-column"),
    document.getElementById("marker-column"),
    document.getElementById("polygon-column"),
    document.getElementById("create-column"),
    document.getElementById("toolbar"),
    document.getElementById("memo-column"),
    document.getElementById("rules-column"),
    document.getElementById("stack-topic-ids"),
    document.getElementById("edit-profile-column"),
    document.getElementById("model-column"),
    document.getElementById("crosshair-column"),
    document.getElementById("rotation-controls"),
    document.getElementById("visibility-controls"),
    document.getElementById("topic-chat-container")

  ];
  
  isToolbarOpen = toolbars.some(toolbar => 
    toolbar.style.display === "block" || toolbar.style.display === "flex"
  );
}
loader.updateProgress();


function handleMovement() {
  if (isToolbarOpen) return;

  const zoom = map.getZoom();
  const panSpeed = 10 * getSpeedMultiplier();
  const zoomSpeed = 0.05 * getSpeedMultiplier();

  if (keys.w) {
    map.panBy([0, -panSpeed], { animate: false });
  }
  if (keys.s) {
    map.panBy([0, panSpeed], { animate: false });
  }

  if (keys.a) {
    map.panBy([-panSpeed, 0], { animate: false });
  }
  if (keys.d) {
    map.panBy([panSpeed, 0], { animate: false });
  }

  if (keys.e) {
    map.setBearing(map.getBearing() + MOVE_SPEED * getSpeedMultiplier());
  }
  if (keys.q) {
    map.setBearing(map.getBearing() - MOVE_SPEED * getSpeedMultiplier());
  }

  if (keys.space) {
    map.setZoom(map.getZoom() + zoomSpeed);
  }
  if (keys.shift) {
    map.setZoom(map.getZoom() - zoomSpeed);
  }

  if (keys.r) {
    map.setPitch(map.getPitch() + 1 * getSpeedMultiplier());
  }
  if (keys.f) {
    map.setPitch(map.getPitch() - 1 * getSpeedMultiplier());
  }
}

document.addEventListener("keydown", (event) => {
  const activeElement = document.activeElement; // Get the currently focused element
  const isInputField = activeElement.tagName === "INPUT" || activeElement.tagName === "TEXTAREA";
  const isSpeedSlider = activeElement.id === "speed-slider"; // Check if the active element is the speed slider

  switch (event.key.toLowerCase()) {
    case "w":
      keys.w = true;
      break;
    case "a":
      keys.a = true;
      break;
    case "s":
      keys.s = true;
      break;
    case "d":
      keys.d = true;
      break;
    case "q":
      keys.q = true;
      break;
    case "e":
      keys.e = true;
      break;
    case " ":
      if (!isInputField || isSpeedSlider) { // Allow spacebar if the active element is the speed slider
        keys.shift = true;
        event.preventDefault();
      }
      break;
    case "shift":
      keys.space = true;
      break;
    case "r":
      keys.r = true;
      break;
    case "f":
      keys.f = true;
      case " ":
  }
});

document.addEventListener("keyup", (event) => {
  switch (event.key.toLowerCase()) {
    case "w":
      keys.w = false;
      break;
    case "a":
      keys.a = false;
      break;
    case "s":
      keys.s = false;
      break;
    case "d":
      keys.d = false;
      break;
    case "q":
      keys.q = false;
      break;
    case "e":
      keys.e = false;
      break;
    case " ":
      keys.shift = false;
      break;
    case "shift":
      keys.space = false;
      break;
    case "r":
      keys.r = false;
      break;
    case "f":
      keys.f = false;
      break;
  }
});

document.addEventListener("click", () => {
  const toolbar = document.getElementById("toolbar");
  const toggleButton = document.getElementById("toggle-toolbar-btn");
  if (!toolbar.contains(event.target) && event.target !== toggleButton) {
    toolbar.style.display = "none";
    isToolbarOpen = false;
  }
});


document.getElementById("toggle-toolbar-btn").addEventListener("click", function(event) {
  // Stop event propagation to prevent document click handler from firing
  event.stopPropagation();
  
  // Get the toolbar element
  const toolbar = document.getElementById("toolbar");
  
  // Toggle isToolbarOpen state
  isToolbarOpen = !isToolbarOpen;
  
  // Explicitly set display style based on current state
  if (isToolbarOpen) {
    toolbar.style.display = "flex";
    console.log("Toolbar should be visible now", toolbar);
  } else {
    toolbar.style.display = "none";
    console.log("Toolbar should be hidden now", toolbar);
  }
  
  // Hide both toggle buttons and show the main button
  document.getElementById("toggle-controls-btn").style.display = "none";
  document.getElementById("toggle-toolbar-btn").style.display = "none";
  document.getElementById("main-toggle-btn").style.display = "block";
  document.getElementById("topic-chat-btn").style.display = "block";
});

// Add a click handler to the toolbar itself to prevent event bubbling
document.getElementById("toolbar").addEventListener("click", function(event) {
  event.stopPropagation();
});



let toggleControlsPressCount = 0; // Initialize a counter for button presses

document.getElementById("toggle-controls-btn").addEventListener("click", () => {
  const speedSlider = document.getElementById("speed-slider");

  toggleControlsPressCount++; // Increment the counter each time the button is pressed

  if (toggleControlsPressCount === 1) {
    // Show the speed slider on the first press
    speedSlider.style.display = "block";
  } else if (toggleControlsPressCount > 3) {
    // Hide the speed slider after the third additional press
    speedSlider.style.display = "none";
    toggleControlsPressCount = 0; // Reset the counter
  }
});

// Modify the document click handler to not close the toolbar if it's clicked
document.addEventListener("click", (event) => {
  const toggleControlsBtn = document.getElementById("toggle-controls-btn");
  const toggleToolbarBtn = document.getElementById("toggle-toolbar-btn");
  const mainToggleBtn = document.getElementById("main-toggle-btn");
  const toolbar = document.getElementById("toolbar");
  const toggleVisibilityControlsBtn = document.getElementById("toggle-visibility-controls-btn");

  // Check if the click is outside the toggle buttons and the main button
  if (
    !toggleControlsBtn.contains(event.target) &&
    !toggleToolbarBtn.contains(event.target) &&
    !mainToggleBtn.contains(event.target) &&
    !toolbar.contains(event.target) &&
    !toggleVisibilityControlsBtn.contains(event.target) // Ensure this line is included
  ) {
    // Hide the toggle buttons
    toggleControlsBtn.style.display = "none";
    toggleToolbarBtn.style.display = "none";
    toggleVisibilityControlsBtn.style.display = "none"; // Hide the visibility controls button
    // Show only the main "Options" button
    mainToggleBtn.style.display = "block";
  }
});

// Ensure the toolbar toggle button also toggles the toolbar visibility
document.getElementById("toggle-toolbar-btn").addEventListener("click", (event) => {
  event.stopPropagation(); // Prevent the click from reaching the document listener
  const toolbar = document.getElementById("toolbar");
  toolbar.style.display = toolbar.style.display === "none" ? "flex" : "none";
});

function closeAllColumns() {
  const columns = [
    "load-column",
    "marker-column",
    "polygon-column",
    "create-column",
    "memo-column",
    "rules-column",
    "stack-topic-ids",
    "model-column",
    "crosshair-column",
    "rotation-controls",
    "edit-profile-column",
    "topic-chat-container",
    "crosshair-column",
    "visibility-controls"
  ];
  
  columns.forEach(columnId => {
    const column = document.getElementById(columnId);
    if (column) {
      column.style.display = "none";
    }
  });
}

document.getElementById("column1").addEventListener("click", (event) => {
  closeAllColumns();
  const inputToolbar = document.getElementById("load-column");
  const toolbarRect = document.getElementById("toolbar").getBoundingClientRect();
  inputToolbar.style.display = "block";
  inputToolbar.style.left = `${toolbarRect.right + 0}px`;
  inputToolbar.style.top = `${toolbarRect.top}px`;
  checkToolbarStatus();
  const loaded_text_area = document.getElementById("loaded-topics");
  loaded_text_area.value = ''; // Clear the current value
  loaded_text_area.value = globalLoadedTopicIdsWithNames.join('\n'); // Update with new values
  adjustTextareaHeight(loaded_text_area); // Adjust height after loading
});

document.getElementById("edit-profile").addEventListener("click", (event) => {
  closeAllColumns();
  const inputToolbar = document.getElementById("edit-profile-column");
  const toolbarRect = document.getElementById("toolbar").getBoundingClientRect();
  inputToolbar.style.display = "block";
  inputToolbar.style.left = `${toolbarRect.right + 0}px`;
  inputToolbar.style.top = `${toolbarRect.top}px`;
  checkToolbarStatus();
});


document.getElementById("stack-topic-ids-column").addEventListener("click", (event) => {
  closeAllColumns();
  const inputToolbar = document.getElementById("stack-topic-ids");
  const toolbarRect = document.getElementById("toolbar").getBoundingClientRect();
  inputToolbar.style.display = "block";
  inputToolbar.style.left = `${toolbarRect.right + 0}px`;
  inputToolbar.style.top = `${toolbarRect.top}px`;
  checkToolbarStatus();
});

      // Add event listeners for the buttons
      document.getElementById("change-model-settings").addEventListener("click", (event) => {
        event.stopPropagation(); // Prevent event bubbling
        closeAllColumns(); // Close any open columns
        document.getElementById("model-column").style.display = "block"; // Show model column
        isToolbarOpen = true;
      });

      document.getElementById("change-crosshair-settings").addEventListener("click", (event) => {
        event.stopPropagation(); // Prevent event bubbling
        closeAllColumns(); // Close any open columns
        document.getElementById("crosshair-column").style.display = "block"; // Show crosshair column
        document.getElementById("crosshair-column-container").style.display = "block"; // Show crosshair column container
        isToolbarOpen = true;
      });

            // Close columns when clicking elsewhere on the screen
            document.addEventListener("click", (event) => {
        const modelColumn = document.getElementById("model-column");
        const crosshairColumn = document.getElementById("crosshair-column");
        if (!modelColumn.contains(event.target) && !crosshairColumn.contains(event.target)) {
          closeAllColumns(); // Close both columns if clicked outside
        }
      });


// Add this event listener to close column1 when clicking outside
document.addEventListener("click", (event) => {
  const inputToolbarColumn1 = document.getElementById("load-column");
  if (
    event.target.id !== "column1" &&
    !inputToolbarColumn1.contains(event.target)
  ) {
    inputToolbarColumn1.style.display = "none";
  }
});

document.addEventListener("click", (event) => {
  const inputToolbarEditProfile = document.getElementById("edit-profile-column");
  if (
    event.target.id !== "edit-profile" &&
    !inputToolbarEditProfile.contains(event.target)
  ) {
    inputToolbarEditProfile.style.display = "none";
  }
});


document.addEventListener("click", (event) => {
  const inputToolbarStackTopicIds = document.getElementById("stack-topic-ids");
  if (
    event.target.id !== "stack-topic-ids" &&
    !inputToolbarStackTopicIds.contains(event.target)
  ) {
    inputToolbarStackTopicIds.style.display = "none";
  }
});




document.getElementById("column2").addEventListener("click", (event) => {
  closeAllColumns();
  const inputToolbarColumn2 = document.getElementById("marker-column");
  const toolbarRect = document.getElementById("toolbar").getBoundingClientRect();
  inputToolbarColumn2.style.display = "block";
  inputToolbarColumn2.style.left = `${toolbarRect.right + 0}px`;
  inputToolbarColumn2.style.top = `${toolbarRect.top}px`;
  checkToolbarStatus();
});

document.getElementById("column3").addEventListener("click", (event) => {
  closeAllColumns();
  const inputToolbarColumn3 = document.getElementById("polygon-column");
  const toolbarRect = document.getElementById("toolbar").getBoundingClientRect();
  inputToolbarColumn3.style.display = "block";
  inputToolbarColumn3.style.left = `${toolbarRect.right + 0}px`;
  inputToolbarColumn3.style.top = `${toolbarRect.top}px`;
  checkToolbarStatus();
});


document.getElementById("column5").addEventListener("click", (event) => {
  closeAllColumns();
  const inputToolbarColumn5 = document.getElementById("create-column");
  const toolbarRect = document.getElementById("toolbar").getBoundingClientRect();
  inputToolbarColumn5.style.display = "block";
  inputToolbarColumn5.style.left = `${toolbarRect.right + 0}px`;
  inputToolbarColumn5.style.top = `${toolbarRect.top}px`;
  checkToolbarStatus();
});

document.getElementById("change-memo").addEventListener("click", (event) => {
  closeAllColumns();
  const inputToolbarSetRules = document.getElementById("memo-column");
  const toolbarRect = document.getElementById("toolbar").getBoundingClientRect();
  inputToolbarSetRules.style.display = "block";
  inputToolbarSetRules.style.left = `${toolbarRect.right + 0}px`;
  inputToolbarSetRules.style.top = `${toolbarRect.top}px`;
  checkToolbarStatus();
});

document.getElementById("set-rules").addEventListener("click", (event) => {
  closeAllColumns();
  const inputToolbarSetRules = document.getElementById("rules-column");
  const toolbarRect = document.getElementById("toolbar").getBoundingClientRect(); 
  inputToolbarSetRules.style.display = "block";
  inputToolbarSetRules.style.left = `${toolbarRect.right + 0}px`;
  inputToolbarSetRules.style.top = `${toolbarRect.top}px`;
  checkToolbarStatus();
});


document.getElementById("column2").addEventListener("click", (event) => {
  const inputToolbarColumn2 = document.getElementById("marker-column");
  const toolbarRect = document.getElementById("toolbar").getBoundingClientRect();
  inputToolbarColumn2.style.display = "block";
  inputToolbarColumn2.style.left = `${toolbarRect.right + 0}px`;
  inputToolbarColumn2.style.top = `${toolbarRect.top}px`;
  checkToolbarStatus();
});

document.getElementById("button3").addEventListener("click", async () => {
try {
  const topicId = document.getElementById("edit-profile-topic-id").value;
  const newName = document.getElementById("toolbar-input").value;

  const meesageobject = {
    changeName: newName
  };

  const meesage = JSON.stringify(meesageobject);
  const reciept = await window.HashinalsWalletConnectSDK.submitMessageToTopic(topicId, meesage);

} catch (error) {
  console.error("Error setting rules:", error);
}
});

document.getElementById("post-msg").addEventListener("click", async () => {
try {
  const newMessage = document.getElementById("user-write-message").value;

let userInput = document.getElementById("topic-chat-topic-id").value.toLowerCase();
let domainEntry = loadedDomains.find(entry => entry.domain === userInput);
let topicId;

if (domainEntry && domainEntry.lastMessage) {
  topicId = domainEntry.lastMessage.topic;
} else {
  topicId = userInput;
}

  const meesageobject = {
    userMessage: newMessage
  };

  const meesage = JSON.stringify(meesageobject);
  const reciept = await window.HashinalsWalletConnectSDK.submitMessageToTopic(topicId, meesage);

} catch (error) {
  console.error("Error setting rules:", error);
}
});



document
.getElementById("submit-button-set-rules")
.addEventListener("click", async () => {
            try {
              let userInput = document.getElementById("input-field-topic-id-for-rules").value.toLowerCase();
              let domainEntry = loadedDomains.find(entry => entry.domain === userInput);
              let topicId;

              if (domainEntry && domainEntry.lastMessage) {
                topicId = domainEntry.lastMessage.topic;
              } else {
                topicId = userInput;
              }
              const polygonTopicId = document.getElementById("input-field-topic-id-for-polygons").value;
              const markerTopicId = document.getElementById("input-field-topic-id-for-markers").value;
              const messagesPerNftPolygon = document.getElementById("input-field-messages-per-nft-for-polygons").value;
              const messagesPerNftMarker = document.getElementById("input-field-messages-per-nft-for-markers").value;
              const SizeForPolygons = document.getElementById("input-field-messages-size-for-polygons").value;

              const meesageobject = {
                rules : { 
                  forpolygon: { 
                    polygonTopicId: polygonTopicId,
                    polygonMessagesPerNft: messagesPerNftPolygon,
                    polygonSize: SizeForPolygons
                  },
                  formarker: {
                    markerTopicId: markerTopicId,
                    markerMessagesPerNft: messagesPerNftMarker
                  }
              }};

              const meesage = JSON.stringify(meesageobject);

              const reciept = await window.HashinalsWalletConnectSDK.submitMessageToTopic(topicId, meesage);
              console.log("Reciept is", reciept);
              
            } catch (error) {
              console.error("Error setting rules:", error);
            }
          });


          document.getElementById("load-topic-rules-for-topic").addEventListener("click", async () => {
    try {
        let userInput = document.getElementById("input-field-topic-id-for-rules").value.toLowerCase();
        let domainEntry = loadedDomains.find(entry => entry.domain === userInput);
        let topicId;

        if (domainEntry && domainEntry.lastMessage) {
            topicId = domainEntry.lastMessage.topic;
        } else {
            topicId = userInput;
        }
        const response = await window.HashinalsWalletConnectSDK.getMessages(topicId);
        const topicInfo = await sdk.getTopicInfo(topicId);
        const topicAdmin = [];
        const memo = topicInfo.memo;

        // Split the memo by commas
        const parts = memo.split(',');

        // Iterate over each part
        parts.forEach(part => {
            // Check if the part starts with "0.0."
            if (part.startsWith("0.0.")) {
                // Add it to the topicAdmin array
                topicAdmin.push(part);
            }
        });

        // Check if messages exist and is an array
        if (!response.messages || !Array.isArray(response.messages)) {
            console.error(`No messages found for topic ${topicId}.`, response);
        }

        const messages = response.messages; // Extract messages
        let lastRule = null;


        // Read rules from messages in reverse order
        for (let index = messages.length - 1; index >= 0; index--) {
            const message = messages[index];
            try {
                let parsedMessage = message;
                if (typeof message === 'string') {
                    parsedMessage = JSON.parse(message);
                }
                if (parsedMessage.rules && (topicAdmin.length === 0 || topicAdmin.includes(message.payer))) {
                    lastRule = parsedMessage.rules;
                    break; // Exit the loop after finding the last message with rules
                }
                
            } catch (messageError) {
                console.error(`Error processing message ${index}:`, messageError);
            }
        }
const loadedNFTsForModel = [];
const loadedNFTScaleForModel = [];
const loadedNFTsForTopicChat = [];


for (let index = 0; index < messages.length; index++) {
  const message = messages[index];
  try {
    let parsedMessage = message;
    if (typeof message === 'string') {
      parsedMessage = JSON.parse(message);
    }
    if (parsedMessage.addTopicNFT && (topicAdmin.length === 0 || topicAdmin.includes(message.payer))) {
  const nfts = parsedMessage.addTopicNFT.split(',').map(nft => nft.trim());
  nfts.forEach(nft => {
    if (!loadedNFTsForModel.includes(nft)) {
      loadedNFTsForModel.push(nft);
    }
  });
}

if (parsedMessage.removeTopicNFT && (topicAdmin.length === 0 || topicAdmin.includes(message.payer))) {
  const nft = parsedMessage.removeTopicNFT.trim();
  const index = loadedNFTsForModel.indexOf(nft);
  if (index !== -1) {
    loadedNFTsForModel.splice(index, 1);
  }
}

  if (parsedMessage.addScale && (topicAdmin.length === 0 || topicAdmin.includes(message.payer))) {
    const { NFT, scale } = parsedMessage.addScale;
    loadedNFTScaleForModel.push({ NFT, scale });
  }

  if (parsedMessage.removeScale && (topicAdmin.length === 0 || topicAdmin.includes(message.payer))) {
    const { NFT } = parsedMessage.removeScale;
    const index = loadedNFTScaleForModel.findIndex(item => item.NFT === NFT);
    if (index !== -1) {
      loadedNFTScaleForModel.splice(index, 1); // Remove the item if it exists
    } else {
      console.log(`NFT: ${NFT} not found in addScale list`);
    }
  }

  if (parsedMessage.addTopicChatNFT && (topicAdmin.length === 0 || topicAdmin.includes(message.payer))) {
  const nfts = parsedMessage.addTopicChatNFT.split(',').map(nft => nft.trim());
  nfts.forEach(nft => {
    if (!loadedNFTsForTopicChat.includes(nft)) {
      loadedNFTsForTopicChat.push(nft);
    }
  });
  console.log("NFT added to topic chat:", loadedNFTsForTopicChat.join(', '));
}

if (parsedMessage.removeTopicChatNFT && (topicAdmin.length === 0 || topicAdmin.includes(message.payer))) {
  const nft = parsedMessage.removeTopicChatNFT.trim();


  const index = loadedNFTsForTopicChat.indexOf(nft);
  if (index !== -1) {
    loadedNFTsForTopicChat.splice(index, 1);
  }
}
}
catch (messageError) {
                console.error(`Error processing message ${index}:`, messageError);
            }
}

let formattedRules = '';
if (lastRule) {
  if (lastRule.forpolygon) {
    const polygonSize = lastRule.forpolygon.polygonSize;
    const maxLongitudeSize = 360 / polygonSize;
    const maxLatitudeSize = 180 / polygonSize;

    formattedRules += 
      `Polygon Topic ID: ${lastRule.forpolygon.polygonTopicId}\n` +
      `Polygon Messages Per NFT: ${lastRule.forpolygon.polygonMessagesPerNft}\n` +
      `Polygon Size: ${polygonSize}\n` +
      `Maximum distance between points is:\n360/${polygonSize}=${maxLongitudeSize} for longitude\n180/${polygonSize}=${maxLatitudeSize} for latitude.\n`;
  }
  if (lastRule.formarker ) {
    formattedRules += 
      `Marker Topic ID: ${lastRule.formarker.markerTopicId}\n` +
      `Marker Messages Per NFT: ${lastRule.formarker.markerMessagesPerNft}\n`;
  }
  if (loadedNFTsForModel.length > 0) {
    formattedRules += `NFTs for model: ${loadedNFTsForModel.join(', ')}\n`;
  }
  if (loadedNFTScaleForModel.length > 0) {
    formattedRules += `Scales for model: ${loadedNFTScaleForModel.map(item => `${item.NFT} = ${item.scale}`).join(', ')}\n`;
  }
  if (loadedNFTsForTopicChat.length > 0) {
    formattedRules += `NFTs for topic chat: ${loadedNFTsForTopicChat.join(', ')}\n`;
  }
}

        // Log the formatted rules onto the textarea
        document.getElementById("loaded-topic-rules-for-topic").textContent = formattedRules;
        adjustTextareaHeight(document.getElementById("loaded-topic-rules-for-topic"));

    } catch (error) {
        console.error("Error creating topic:", error);
    }
});

          

          document
.getElementById("button5")
.addEventListener("click", async () => {
            try {
              const topicId = '0.0.9606779';
              const topic = document.getElementById("edit-profile-topic-id").value;
              const domain = document.getElementById("toolbar-input").value.toLowerCase();


              const meesageobject = {
                topic : topic,
                domain : domain
              };

              const meesage = JSON.stringify(meesageobject);

              const reciept = await window.HashinalsWalletConnectSDK.submitMessageToTopic(topicId, meesage);
              console.log("Reciept is", reciept);
              
            } catch (error) {
              console.error("Error setting rules:", error);
            }
          });



          document
.getElementById("submit-button-add-scale-for-model")
.addEventListener("click", async () => {
            try {
              let userInput = document.getElementById("input-field-topic-id-for-rules").value.toLowerCase();
              let domainEntry = loadedDomains.find(entry => entry.domain === userInput);
              let topicId;

              if (domainEntry && domainEntry.lastMessage) {
                topicId = domainEntry.lastMessage.topic;
              } else {
                topicId = userInput;
              }
              const stackTopicAddTopicNFT = document.getElementById("input-field-add-remove-NFT-for-model").value;
              const stackTopicAddScale = document.getElementById("input-field-add-remove-scale-for-model").value;


              const meesageobject = {
                    addScale:{
                      NFT: stackTopicAddTopicNFT,
                      scale: stackTopicAddScale
                    }
              };

              const meesage = JSON.stringify(meesageobject);

              const reciept = await window.HashinalsWalletConnectSDK.submitMessageToTopic(topicId, meesage);
              console.log("Reciept is", reciept);
              
            } catch (error) {
              console.error("Error setting rules:", error);
            }
          });

          document
.getElementById("submit-button-remove-scale-for-model")
.addEventListener("click", async () => {
            try {
              let userInput = document.getElementById("input-field-topic-id-for-rules").value.toLowerCase();
              let domainEntry = loadedDomains.find(entry => entry.domain === userInput);
              let topicId;

              if (domainEntry && domainEntry.lastMessage) {
                topicId = domainEntry.lastMessage.topic;
              } else {
                topicId = userInput;
              }
              const stackTopicRemoveTopicNFT = document.getElementById("input-field-add-remove-NFT-for-model").value;

              const meesageobject = {
                      removeScale:{
                        NFT: stackTopicRemoveTopicNFT
                      }
              };

              const meesage = JSON.stringify(meesageobject);

              const reciept = await window.HashinalsWalletConnectSDK.submitMessageToTopic(topicId, meesage);
              console.log("Reciept is", reciept);
              
            } catch (error) {
              console.error("Error setting rules:", error);
            }
          });

          document
.getElementById("submit-button-add-NFT-for-model")
.addEventListener("click", async () => {
            try {
              let userInput = document.getElementById("input-field-topic-id-for-rules").value.toLowerCase();
              let domainEntry = loadedDomains.find(entry => entry.domain === userInput);
              let topicId;

              if (domainEntry && domainEntry.lastMessage) {
                topicId = domainEntry.lastMessage.topic;
              } else {
                topicId = userInput;
              }
              const stackTopicAddTopicNFT = document.getElementById("input-field-add-remove-NFT-for-model").value;


              const meesageobject = {
                    addTopicNFT: stackTopicAddTopicNFT
              };

              const meesage = JSON.stringify(meesageobject);

              const reciept = await window.HashinalsWalletConnectSDK.submitMessageToTopic(topicId, meesage);
              console.log("Reciept is", reciept);
              
            } catch (error) {
              console.error("Error setting rules:", error);
            }
          });
          loader.updateProgress();
          document
.getElementById("submit-button-remove-NFT-for-model")
.addEventListener("click", async () => {
            try {
              let userInput = document.getElementById("input-field-topic-id-for-rules").value.toLowerCase();
              let domainEntry = loadedDomains.find(entry => entry.domain === userInput);
              let topicId;

              if (domainEntry && domainEntry.lastMessage) {
                topicId = domainEntry.lastMessage.topic;
              } else {
                topicId = userInput;
              }
              const stackTopicRemoveTopicNFT = document.getElementById("input-field-add-remove-NFT-for-model").value;


              const meesageobject = {
                  removeTopicNFT: stackTopicRemoveTopicNFT
              };

              const meesage = JSON.stringify(meesageobject);

              const reciept = await window.HashinalsWalletConnectSDK.submitMessageToTopic(topicId, meesage);
              console.log("Reciept is", reciept);
              
            } catch (error) {
              console.error("Error setting rules:", error);
            }
          });

          document
.getElementById("submit-button-add-topic-chat")
.addEventListener("click", async () => {
            try {
              let userInput = document.getElementById("input-field-topic-id-for-rules").value.toLowerCase();
              let domainEntry = loadedDomains.find(entry => entry.domain === userInput);
              let topicId;

              if (domainEntry && domainEntry.lastMessage) {
                topicId = domainEntry.lastMessage.topic;
              } else {
                topicId = userInput;
              }
              const stackTopicAddTopicNFT = document.getElementById("input-field-add-remove-topic-chat").value;


              const meesageobject = {
                    addTopicChatNFT: stackTopicAddTopicNFT
              };

              const meesage = JSON.stringify(meesageobject);

              const reciept = await window.HashinalsWalletConnectSDK.submitMessageToTopic(topicId, meesage);
              console.log("Reciept is", reciept);
              
            } catch (error) {
              console.error("Error setting rules:", error);
            }
          });

          document
.getElementById("submit-button-remove-topic-chat")
.addEventListener("click", async () => {
            try {
              let userInput = document.getElementById("input-field-topic-id-for-rules").value.toLowerCase();
              let domainEntry = loadedDomains.find(entry => entry.domain === userInput);
              let topicId;

              if (domainEntry && domainEntry.lastMessage) {
                topicId = domainEntry.lastMessage.topic;
              } else {
                topicId = userInput;
              }
              const stackTopicRemoveTopicNFT = document.getElementById("input-field-add-remove-topic-chat").value;


              const meesageobject = {
                  removeTopicChatNFT: stackTopicRemoveTopicNFT
              };

              const meesage = JSON.stringify(meesageobject);

              const reciept = await window.HashinalsWalletConnectSDK.submitMessageToTopic(topicId, meesage);
              console.log("Reciept is", reciept);
              
            } catch (error) {
              console.error("Error setting rules:", error);
            }
          });



          document
.getElementById("add-topic-id")
.addEventListener("click", async () => {
            try {
              let userInput = document.getElementById("stack-topic-ids-topic").value.toLowerCase();
    let domainEntry = loadedDomains.find(entry => entry.domain === userInput);
    let topicId;

    if (domainEntry && domainEntry.lastMessage) {
      topicId = domainEntry.lastMessage.topic;
    } else {
      topicId = userInput;
    }
              const stackTopicAddTopic = document.getElementById("stack-topic-add-topic").value;


              const meesageobject = {
                  addTopic: { 
                    addTopic: stackTopicAddTopic
                  },
              };

              const meesage = JSON.stringify(meesageobject);

              const reciept = await window.HashinalsWalletConnectSDK.submitMessageToTopic(topicId, meesage);
              console.log("Reciept is", reciept);
              
            } catch (error) {
              console.error("Error setting rules:", error);
            }
          });

          document
.getElementById("remove-topic-id")
.addEventListener("click", async () => {
            try {
              let userInput = document.getElementById("stack-topic-ids-topic").value.toLowerCase();
    let domainEntry = loadedDomains.find(entry => entry.domain === userInput);
    let topicId;

    if (domainEntry && domainEntry.lastMessage) {
      topicId = domainEntry.lastMessage.topic;
    } else {
      topicId = userInput;
    }
              const stackTopicRemoveTopic = document.getElementById("stack-topic-remove-topic").value;


              const meesageobject = {
                removeTopic: {
                  removeTopic: stackTopicRemoveTopic
                }
              };

              const meesage = JSON.stringify(meesageobject);

              const reciept = await window.HashinalsWalletConnectSDK.submitMessageToTopic(topicId, meesage);
              console.log("Reciept is", reciept);
              
            } catch (error) {
              console.error("Error setting rules:", error);
            }
          });

document
  .getElementById("submit-button-column2")
  .addEventListener("click", async () => {
    try {
      let userInput = document.getElementById("input-field-2-0").value.toLowerCase();
      let domainEntry = loadedDomains.find(entry => entry.domain === userInput);
      let topicId;

      if (domainEntry && domainEntry.lastMessage) {
        topicId = domainEntry.lastMessage.topic;
      } else {
        topicId = userInput;
      }
      const title = document.getElementById("input-field-2-1").value;
      const imageurl = document.getElementById("input-field-image-marker").value;
      const coverimage = document.getElementById("input-field-coverimage-marker").value;
      const cleanUrl = imageurl.replace(/\?network=mainnet$/, "");
      const cleanCoverimage = coverimage.replace(/\?network=mainnet$/, "");
      const msg = document.getElementById("input-field-2-2").value;
      const cord = document.getElementById("input-field-2-3").value;
      const numberOfMarker = document.getElementById("input-field-number-of-marker").value;

            // Check if the input is a whole number
            if (numberOfMarker === "" || !Number.isInteger(Number(numberOfMarker))) {
          alert("Please enter a valid whole number for the Number of Marker.");
          return; // Stop the submission if the input is not a whole number
      }

      if (!numberOfMarker || !topicId || !cord) {
            alert("Please fill in all required fields: Number of Marker, Topic ID, and Coordinates.");
            return; // Stop the submission if any field is empty
          }
      
      const messageObj = {marker: {data: {title: title, image: [cleanUrl], coverimage: [cleanCoverimage], msg: msg, cord: cord, numberOfMarker: numberOfMarker }}};
      const message = JSON.stringify(messageObj); // Convert to string
      
      const receipt = await window.HashinalsWalletConnectSDK.submitMessageToTopic(
        topicId,
        message // Send stringified message
      );
      console.log('Receipt:', receipt);
      
      // Clear inputs after successful submission
      document.getElementById("input-field-2-0").value = '';
      document.getElementById("input-field-2-1").value = '';
      document.getElementById("input-field-2-2").value = '';
      document.getElementById("input-field-2-3").value = '';
      
    } catch (error) {
      console.error('Error submitting message:', error);
    }
  });

document.addEventListener("click", (event) => {
  const inputToolbarColumn2 = document.getElementById(
    "marker-column"
  );
  if (
    event.target.id !== "column2" &&
    !inputToolbarColumn2.contains(event.target)
  ) {
    inputToolbarColumn2.style.display = "none";
  }
});

document.getElementById("column3").addEventListener("click", (event) => {
  const inputToolbarColumn3 = document.getElementById("polygon-column");
  const toolbarRect = document.getElementById("toolbar").getBoundingClientRect();
  inputToolbarColumn3.style.display = "block";
  inputToolbarColumn3.style.left = `${toolbarRect.right + 0}px`;
  inputToolbarColumn3.style.top = `${toolbarRect.top}px`;
  checkToolbarStatus();
});

document
  .getElementById("submit-button-column3")
  .addEventListener("click", async () => {
    try {
      let userInput = document.getElementById("input-field-3-0").value.toLowerCase();
      let domainEntry = loadedDomains.find(entry => entry.domain === userInput);
      let topicId;

      if (domainEntry && domainEntry.lastMessage) {
        topicId = domainEntry.lastMessage.topic;
      } else {
        topicId = userInput;
      }
      const title = document.getElementById("input-field-3-1").value;
      const msg = document.getElementById("input-field-3-2").value;
      const imageurl = document.getElementById("input-field-image-polygon").value;
      const coverimage = document.getElementById("input-field-coverimage-polygon").value;
      const cord1 = document.getElementById("input-field-3-3").value; // TOP LEFT
      const cord3 = document.getElementById("input-field-3-5").value; // BOTTOM RIGHT
      const numberOfPolygon = document.getElementById("input-field-number-of-polygon").value;
      const cleanUrl = imageurl.replace(/\?network=mainnet$/, "");
      const cleanCoverimage = coverimage.replace(/\?network=mainnet$/, "");

            // Check if the input is a whole number
            if (numberOfPolygon === "" || !Number.isInteger(Number(numberOfPolygon))) {
          alert("Please enter a valid whole number for the Number of Polygon.");
          return; // Stop the submission if the input is not a whole number
      }

      if (!numberOfPolygon || !topicId || !cord1 || !cord3) {
            alert("Please fill in all required fields: Number of Polygon, Topic ID, and Coordinates.");
            return; // Stop the submission if any field is empty
          }

      // Validate and format the coordinates input
      const Cords = {
        cord1 : cord1.split(',').map(Number), // Convert to array of numbers
        cord3 : cord3.split(',').map(Number),
      };

      const formattedCord = [
        Cords.cord1,
        [Cords.cord1[0],Cords.cord3[1]],
        Cords.cord3,
        [Cords.cord3[0],Cords.cord1[1]]
      ];

      // Ensure all coordinates are valid numbers
      const isValid = formattedCord.every(cord => 
        Array.isArray(cord) && 
        cord.length === 2 && 
        cord.every(num => !isNaN(num) && isFinite(num))
      );

      if (!isValid) {
        throw new Error('Please enter valid coordinates in the format number,number for all four corners.');
      }

      // Create the desired coordinate string without additional array wrapping
      const cordString = formattedCord.map(cord => `[${cord.join(',')}]`).join(', '); // Join the valid coordinates
            
      const messageObj = {
        polygon: {
          data: {
            title: title,
            image: [cleanUrl],
            coverimage: [cleanCoverimage],
            msg: msg,
            cord: cordString,
            numberOfPolygon: numberOfPolygon
          }
        }
      };
      const message = JSON.stringify(messageObj);
      
      const receipt = await window.HashinalsWalletConnectSDK.submitMessageToTopic(
        topicId,
        message
      );
      console.log('Receipt:', receipt);
      
      // Clear inputs after successful submission
      document.getElementById("input-field-3-0").value = '';
      document.getElementById("input-field-3-1").value = '';
      document.getElementById("input-field-3-2").value = '';
      document.getElementById("input-field-3-3").value = '';
      document.getElementById("input-field-3-4").value = '';
      document.getElementById("input-field-3-5").value = '';
      document.getElementById("input-field-3-6").value = '';
      
    } catch (error) {
      console.error('Error submitting message:', error);
    }
  });



document.addEventListener("click", (event) => {
  const inputToolbarColumn3 = document.getElementById(
    "polygon-column"
  );
  if (
    event.target.id !== "column3" &&
    !inputToolbarColumn3.contains(event.target)
  ) {
    inputToolbarColumn3.style.display = "none";
  }
});


document.addEventListener("click", (event) => {
  const inputToolbarColumn5 = document.getElementById(
    "create-column"
  );
  if (
    event.target.id !== "column5" &&
    !inputToolbarColumn5.contains(event.target)
  ) {
    inputToolbarColumn5.style.display = "none";
  }
});

document.addEventListener("click", (event) => {
  const inputToolbarSetRules = document.getElementById("memo-column");
  if (
    event.target.id !== "change-memo" &&
    !inputToolbarSetRules.contains(event.target)
  ) {
    inputToolbarSetRules.style.display = "none";
  }
});

document.addEventListener("click", (event) => {
  const inputToolbarSetRules = document.getElementById("rules-column");
  if (
    event.target.id !== "set-rules" &&
    !inputToolbarSetRules.contains(event.target)
  ) {
    inputToolbarSetRules.style.display = "none";
  }
});


function adjustButtonSize() {
    const coordinatesDisplay = document.getElementById('coordinates-display');
    const copyCoordinatesButton = document.getElementById('copy-coordinates');

    // Get the computed styles of the input field
    const computedStyle = window.getComputedStyle(coordinatesDisplay);

    // Set the button's width and height to match the input field
    copyCoordinatesButton.style.width = computedStyle.width;
    copyCoordinatesButton.style.height = computedStyle.height;
  }

  // Call the function initially to set the size
  adjustButtonSize();

  // Optionally, add an event listener to adjust size on window resize
  window.addEventListener('resize', adjustButtonSize);



// Declare cumulative variables outside animate to persist state
let cumulativeLng = 0; // Initialize with 0 or initial lng
let prevLng = 0; // Previous longitude
let cumulativeLat = 0; // Initialize with 0 or initial lat
let prevLat = 0; // Previous latitude

function animate() {
  requestAnimationFrame(animate);
  handleMovement();

  const zoomLevel = map.getZoom().toFixed(1);
  const pitchAngle = Math.round(map.getPitch());
  const center = map.getCenter();
  const lat = center.lat.toFixed(5);
  const lng = center.lng.toFixed(5);

  const coordinatesDisplay = document.getElementById("coordinates-display");
  coordinatesDisplay.value = `lng,lat = ${lng},${lat}`;

  // Create a temporary span to measure the text width
  const tempSpan = document.createElement("span");
  tempSpan.style.visibility = "hidden";
  tempSpan.style.position = "absolute";
  tempSpan.style.whiteSpace = "nowrap";
  tempSpan.style.font = window.getComputedStyle(coordinatesDisplay).font;
  tempSpan.textContent = coordinatesDisplay.value;
  document.body.appendChild(tempSpan);

  // Set the input width based on the span width
  coordinatesDisplay.style.width = `${tempSpan.offsetWidth}px`; // Add some padding
  document.body.removeChild(tempSpan);

  // Smooth longitude transition
  let deltaLng = lng - prevLng;
  if (deltaLng > 180) deltaLng -= 360; // Shortest path for longitude
  else if (deltaLng < -180) deltaLng += 360;
  cumulativeLng += deltaLng;
  prevLng = lng;

  // Smooth latitude transition
  let deltaLat = lat - prevLat;
  if (deltaLat > 90) deltaLat -= 180; // Shortest path for latitude
  else if (deltaLat < -90) deltaLat += 180;
  cumulativeLat += deltaLat;
  prevLat = lat;

  // Apply rotations: Map 360 degrees of lng to 2π radians (full circle)
  stars.rotation.y = -(cumulativeLng * Math.PI) / 180; // Convert degrees to radians
  stars.rotation.x = (cumulativeLat * Math.PI) / 180; // Convert degrees to radians for latitude

  renderer.render(scene, camera);
}

// Initialize with starting longitude and latitude
function initializeRotation(initialLng, initialLat) {
  cumulativeLng = initialLng;
  prevLng = initialLng;
  cumulativeLat = initialLat;
  prevLat = initialLat;
}

// Example: Call this when your map or scene is initialized
// initializeRotation(map.getCenter().lng, map.getCenter().lat);

window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
  map.resize();
});

animate();

function openPopup(marker) {
  new maplibregl.Popup({ anchor: 'bottom'})
    .setLngLat(marker.geometry.coordinates)
    .setText(marker.properties.message)
    .addTo(map);
}

const index = new Supercluster({
  radius: 60,
  maxZoom: 11,
});

// Only load features if there are any
if (geojson.features.length > 0) {
  index.load(geojson.features);
}

function debounce(func, wait) {
  let timeout;
  return function (...args) {
    const context = this;
    clearTimeout(timeout);
    timeout = setTimeout(() => func.apply(context, args), wait);
  };
}

let existingMarkers = [];

function createLowQualityImage(imageUrl, size = 32) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.crossOrigin = "Anonymous";
    img.onload = () => {
      // Create a small canvas for the low quality version
      const canvas = document.createElement('canvas');
      canvas.width = size;
      canvas.height = size;
      const ctx = canvas.getContext('2d');
      
      // Draw image at lower resolution
      ctx.drawImage(img, 0, 0, size, size);
      
      // Convert to low quality JPEG-like format
      resolve(canvas.toDataURL('image/jpeg', 0.5));
    };
    img.onerror = reject;
    img.src = imageUrl;
  });
}

let lastBounds = null;

function updateClusters() {
  if (geojson.features.length === 0) {
    console.log("No features to update clusters."); // Debugging log
    return;
  }

  const currentBounds = map.getBounds().toArray().flat();
  
  // Remove the bounds change check to always update clusters
  lastBounds = currentBounds;
  
  const zoom = map.getZoom();
  const clusters = index.getClusters(currentBounds, Math.floor(zoom));
  
  // Remove existing markers
  existingMarkers.forEach((marker) => marker.remove());
  existingMarkers = [];

  clusters.forEach(async (cluster) => {
    const el = document.createElement("div");
    el.className = cluster.properties.cluster ? "cluster-marker" : "marker";
    const iconSize = [`${5}vh`, `${5}vh`];
    el.style.width = iconSize[0];
    el.style.height = iconSize[1];
    el.style.cursor = "pointer";
    el.style.borderRadius = "50%";

    if (cluster.properties.cluster) {
      el.textContent = cluster.properties.point_count_abbreviated;
      el.style.color = "black";
      el.style.textAlign = "center";
      el.style.lineHeight = iconSize[0];
      el.style.backgroundColor = "rgba(255, 255, 255, 0.8)";

      // Add click event listener for clusters
      el.addEventListener("click", async (e) => {
        e.stopPropagation();
        const expansionZoom = await index.getClusterExpansionZoom(cluster.id);
        map.easeTo({
          center: cluster.geometry.coordinates,
          zoom: expansionZoom,
        });
      });
    } else {
      try {
        // Create low quality version of the image
        const lowQualityUrl = await createLowQualityImage(cluster.properties.imageUrl);
        el.style.backgroundImage = `url(${lowQualityUrl})`;
        el.style.backgroundSize = "cover";
        
        // Load high quality version in the background
        const img = new Image();
        img.onload = () => {
          el.style.backgroundImage = `url(${cluster.properties.imageUrl})`;
        };
        img.src = cluster.properties.imageUrl;
      } catch (error) {
        console.error("Error loading marker image:", error);
        // Use a fallback color or image
        el.style.backgroundColor = "rgba(255, 255, 255, 0.8)";
      }
    }

    const marker = new maplibregl.Marker({ element: el })
      .setLngLat(cluster.geometry.coordinates)
      .addTo(map);

    if (!cluster.properties.cluster) {
      const popup = new maplibregl.Popup({ anchor: 'bottom'}).setHTML(
        cluster.properties.message
      );
      
      el.addEventListener("click", (e) => {
        e.stopPropagation(); // Stop event from reaching polygon layer
        if (!cluster.properties.cluster) {
          popup.setLngLat(cluster.geometry.coordinates).addTo(map);
        }
      });
    }

    existingMarkers.push(marker);
  });

}

const debouncedUpdateClusters = debounce(updateClusters, 2000); // Increase from 200 to 1000ms

// map.on("moveend", debouncedUpdateClusters);

window.addEventListener("beforeunload", () => {
  map.remove();
  scene.clear();
  renderer.dispose();
});

function createResizedImage(imageUrl, maxWidth = 256, maxHeight = 256) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.crossOrigin = "Anonymous";
    
    img.onload = () => {
      const canvas = document.createElement('canvas');
      let width = img.width;
      let height = img.height;
      
      // Calculate new dimensions while maintaining aspect ratio
      if (width > height) {
        if (width > maxWidth) {
          height = Math.round(height * (maxWidth / width));
          width = maxWidth;
        }
      } else {
        if (height > maxHeight) {
          width = Math.round(width * (maxHeight / height));
          height = maxHeight;
        }
      }
      
      canvas.width = width;
      canvas.height = height;
      
      const ctx = canvas.getContext('2d');
      // Use better image smoothing
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
      
      ctx.drawImage(img, 0, 0, width, height);
      resolve(canvas.toDataURL('image/jpeg', 1)); // Adjust quality here (0-1)
    };
    
    img.onerror = reject;
    img.src = imageUrl;
  });
}

// Track added layers to avoid duplicates
const addedLayers = new Set();

function addPolygonWithImageFill(map, polygon) {
  const sourceId = `${polygon.id}-source`;
  const layerId = `${polygon.id}-image-layer`;
  const maskLayerId = `${polygon.id}-mask-layer`;

    // Check if the source already exists
    if (map.getSource(sourceId)) {
    return; // Skip adding this polygon if the source already exists
  }
  // Calculate the bounding box of the polygon
  const coordinates = polygon.coordinates[0];
  const bounds = coordinates.reduce((bounds, coord) => {
    return {
      minLng: Math.min(bounds.minLng, coord[0]),
      maxLng: Math.max(bounds.maxLng, coord[0]),
      minLat: Math.min(bounds.minLat, coord[1]),
      maxLat: Math.max(bounds.maxLat, coord[1])
    };
  }, {
    minLng: Infinity,
    maxLng: -Infinity,
    minLat: Infinity,
    maxLat: -Infinity
  });

  // Create and add the resized image
  createResizedImage(polygon.imageUrl, 512, 512)
    .then(resizedImageUrl => {
      map.addSource(sourceId, {
        type: 'image',
        url: resizedImageUrl,
        coordinates: [
          [bounds.minLng, bounds.maxLat],
          [bounds.maxLng, bounds.maxLat],
          [bounds.maxLng, bounds.minLat],
          [bounds.minLng, bounds.minLat]
        ]
      });

      map.addLayer({
  id: layerId,
  type: 'raster',
  source: sourceId,
  paint: {
    'raster-opacity': 1,
    'raster-fade-duration': 0,
    'raster-resampling': 'linear',
    'raster-brightness-min': 0,
    'raster-brightness-max': 1,
    'raster-contrast': 0,
    'raster-saturation': 0
  },
  layout: {
    'visibility': 'visible'
  },
  interactive: false // Disable click interactions
});

        document.getElementById("raster-opacity-slider").addEventListener("input", (event) => {
        const opacityValue = event.target.value; // Get the current value of the slider
        map.setPaintProperty(layerId, 'raster-opacity', parseFloat(opacityValue)); // Update the layer's opacity
      });

      // Add mask for the polygon
      const maskSourceId = `${polygon.id}-mask-source`;


      map.addSource(maskSourceId, {
        type: 'geojson',
        data: {
          type: 'Feature',
          properties: {},
          geometry: {
            type: 'Polygon',
            coordinates: polygon.coordinates
          }
        }
      });

      map.addLayer({
  id: maskLayerId,
  type: 'fill',
  source: maskSourceId,
  paint: {
    'fill-opacity': 0, // Set back to 0 for invisibility after debugging
    'fill-outline-color': '#000'
  }
}, layerId); // Ensure mask layer is above raster layer

      // Add interactivity
      const popup = new maplibregl.Popup({ anchor: 'bottom'});

      // Check if the layer has already been added
      if (!addedLayers.has(maskLayerId)) {
        map.on('click', maskLayerId, (e) => {
          if (polygon.description) {
            popup
              .setLngLat(e.lngLat)
              .setHTML(polygon.description)
              .addTo(map);
          }
        });

        map.on('mouseenter', maskLayerId, () => {
          map.getCanvas().style.cursor = 'pointer';
        });

        map.on('mouseleave', maskLayerId, () => {
          map.getCanvas().style.cursor = '';
        });

        // Mark this layer as added
        addedLayers.add(maskLayerId);
      }
    })
    .catch(error => {
      console.error('Error loading or resizing image:', error);
    });
}

      const leftUpButton = document.getElementById("left-up");
      const leftLeftButton = document.getElementById("left-left");
      const leftRightButton = document.getElementById("left-right");
      const leftDownButton = document.getElementById("left-down");

      const rightUpButton = document.getElementById("right-up");
      const rightLeftButton = document.getElementById("right-left");
      const rightRightButton = document.getElementById("right-right");
      const rightDownButton = document.getElementById("right-down");

      const activeIntervals = new Set();

      function setupButton(buttonElement, action) {
        let intervalId;
        
        const startAction = (event) => {
          event.preventDefault();
          if (!intervalId) {
            intervalId = setInterval(action, 16); // 60fps timing
            activeIntervals.add(intervalId);
          }
        };

        const stopAction = () => {
          if (intervalId) {
            clearInterval(intervalId);
            activeIntervals.delete(intervalId);
            intervalId = null;
          }
        };

        buttonElement.addEventListener("mousedown", startAction);
        buttonElement.addEventListener("mouseup", stopAction);
        buttonElement.addEventListener("mouseleave", stopAction);
        
        buttonElement.addEventListener("touchstart", startAction);
        buttonElement.addEventListener("touchend", stopAction);
        buttonElement.addEventListener("touchcancel", stopAction);
      }

      setupButton(leftUpButton, () => map.panBy([0, -BUTTON_PAN_SPEED * getSpeedMultiplier()], { animate: false }));
      setupButton(leftDownButton, () => map.panBy([0, BUTTON_PAN_SPEED * getSpeedMultiplier()], { animate: false }));
      setupButton(leftLeftButton, () => map.panBy([-BUTTON_PAN_SPEED * getSpeedMultiplier(), 0], { animate: false }));
      setupButton(leftRightButton, () => map.panBy([BUTTON_PAN_SPEED * getSpeedMultiplier(), 0], { animate: false }));

      setupButton(rightUpButton, () => map.setZoom(map.getZoom() + BUTTON_ZOOM_SPEED * getSpeedMultiplier()));
      setupButton(rightDownButton, () => map.setZoom(map.getZoom() - BUTTON_ZOOM_SPEED * getSpeedMultiplier()));

      setupButton(rightLeftButton, () => map.setBearing(map.getBearing() - MOVE_SPEED * getSpeedMultiplier()));
      setupButton(rightRightButton, () => map.setBearing(map.getBearing() + MOVE_SPEED * getSpeedMultiplier()));

      setupButton(document.getElementById("zoom-in"), () => map.setPitch(map.getPitch() + 1 * getSpeedMultiplier()));
      setupButton(document.getElementById("zoom-out"), () => map.setPitch(map.getPitch() - 1 * getSpeedMultiplier()));

      window.addEventListener("beforeunload", () => {
        activeIntervals.forEach(interval => clearInterval(interval));
        activeIntervals.clear();
      });

      document.getElementById("toggle-controls-btn").addEventListener("click", () => {
        const zoomControls = document.getElementById("zoom-controls");
        const leftDpad = document.getElementById("left-dpad");
        const rightDpad = document.getElementById("right-dpad");

        const isVisible = zoomControls.style.display === "flex";

        zoomControls.style.display = isVisible ? "none" : "flex";
        leftDpad.style.display = isVisible ? "none" : "grid";
        rightDpad.style.display = isVisible ? "none" : "grid";
      });

      // Add event listeners for the new buttons
      document.getElementById("button1").addEventListener("click", async (event) => {
        event.stopPropagation();
        const inputValue = document.getElementById("toolbar-input").value;
        
        try {
          const topicId = "0.0.9609881";
          const cleanUrl = inputValue.replace(/\?network=mainnet$/, "");

          const messageData = {
            data: {
              urls: [cleanUrl],
            },
          };
          const message = JSON.stringify(messageData);

          const receipt = await sdk.submitMessageToTopic(
            topicId,
            message
          );
          console.log("Profile picture updated successfully:", receipt);
          
          document.getElementById("toolbar-input").value = "";
          
        } catch (error) {
          console.error("Error updating profile picture:", error);
          // Removed alert
        }
      });

      document.getElementById("button2").addEventListener("click", async (event) => {
        event.stopPropagation();
        const inputValue = document.getElementById("toolbar-input").value;
        
        try {
          const topicId = "0.0.9609904";
          
          const messageData = {
            data: {
              username: inputValue,
            },
          };
          const message = JSON.stringify(messageData);

          const receipt = await sdk.submitMessageToTopic(
            topicId,
            message
          );
          console.log("Username updated successfully:", receipt);
          
          document.getElementById("toolbar-input").value = "";
          
        } catch (error) {
          console.error("Error updating username:", error);
          // Removed alert
        }
      });


      document.addEventListener('touchstart', (event) => {
        if (event.touches.length > 1) {
          event.preventDefault();
        }
      }, { passive: false });

      let lastTouchEnd = 0;
      document.addEventListener('touchend', (event) => {
        const now = (new Date()).getTime();
        if (now - lastTouchEnd <= 300) {
          event.preventDefault();
        }
        lastTouchEnd = now;
      }, { passive: false });
      
      // Prevent zoom on input focus for iOS
      document.addEventListener('gesturestart', (event) => {
        event.preventDefault();
      }, { passive: false });


function closeOptions() {
  const toggleControlsBtn = document.getElementById("toggle-controls-btn");
  const toggleToolbarBtn = document.getElementById("toggle-toolbar-btn");
  const mainToggleBtn = document.getElementById("main-toggle-btn");
  const toolbar = document.getElementById("toolbar");
  const toggleRotationControlsBtn = document.getElementById("toggle-rotation-controls-btn");
  const rotationControls = document.getElementById("rotation-controls");
  const toggleVisibilityControlsBtn = document.getElementById("toggle-visibility-controls-btn");
  const visibilityControls = document.getElementById("visibility-controls");
  const topicChatBtn = document.getElementById("topic-chat-btn");
  const topicChatContainer = document.getElementById("topic-chat-container");
  const crosshairColumn = document.getElementById("crosshair-column");
  const crosshairColumnContainer = document.getElementById("crosshair-column-container");


  toggleControlsBtn.style.display = "none";
  topicChatContainer.style.display = "none";
  toggleToolbarBtn.style.display = "none";
  toggleRotationControlsBtn.style.display = "none";
  rotationControls.style.display = "none";
  toolbar.style.display = "none";
  toggleVisibilityControlsBtn.style.display = "none";
  visibilityControls.style.display = "none";
  mainToggleBtn.style.display = "block";
  topicChatBtn.style.display = "block";

  // Close all input toolbars
  const inputToolbars = [
    "load-column",
    "marker-column",
    "polygon-column",
    "create-column",
    "memo-column",
    "rules-column",
    "stack-topic-ids",
    "edit-profile-column",
    "model-column",
    "visibility-controls",
    "crosshair-column",
    "crosshair-column-container"
  ];
  
  inputToolbars.forEach(toolbarId => {
    const inputToolbar = document.getElementById(toolbarId);
    if (inputToolbar) {
      inputToolbar.style.display = "none";
    }
  });


}

function closeOptionsWithoutChat() {
  const toggleControlsBtn = document.getElementById("toggle-controls-btn");
  const toggleToolbarBtn = document.getElementById("toggle-toolbar-btn");
  const mainToggleBtn = document.getElementById("main-toggle-btn");
  const toolbar = document.getElementById("toolbar");
  const toggleRotationControlsBtn = document.getElementById("toggle-rotation-controls-btn");
  const rotationControls = document.getElementById("rotation-controls");
  const toggleVisibilityControlsBtn = document.getElementById("toggle-visibility-controls-btn");
  const visibilityControls = document.getElementById("visibility-controls");
  const topicChatBtn = document.getElementById("topic-chat-btn");
  const topicChatContainer = document.getElementById("topic-chat-container");
  const crosshairColumn = document.getElementById("crosshair-column");
  const crosshairColumnContainer = document.getElementById("crosshair-column-container");


  toggleControlsBtn.style.display = "none";
  toggleToolbarBtn.style.display = "none";
  toggleRotationControlsBtn.style.display = "none";
  rotationControls.style.display = "none";
  toolbar.style.display = "none";
  toggleVisibilityControlsBtn.style.display = "none";
  visibilityControls.style.display = "none";
  mainToggleBtn.style.display = "block";
  topicChatBtn.style.display = "block";

  // Close all input toolbars
  const inputToolbars = [
    "load-column",
    "marker-column",
    "polygon-column",
    "create-column",
    "memo-column",
    "rules-column",
    "stack-topic-ids",
    "edit-profile-column",
    "model-column",
    "visibility-controls",
    "crosshair-column",
    "crosshair-column-container"
  ];
  
  inputToolbars.forEach(toolbarId => {
    const inputToolbar = document.getElementById(toolbarId);
    if (inputToolbar) {
      inputToolbar.style.display = "none";
    }
  });


}





document.getElementById("main-toggle-btn").addEventListener("click", function(e) {
  e.stopPropagation();
  
  closeOptions();

  // Reset the toolbar state
  isToolbarOpen = false; // Ensure the toolbar state is reset

  // Show the toggle buttons and hide the main button
  document.getElementById("toggle-controls-btn").style.display = "block";
  document.getElementById("toggle-toolbar-btn").style.display = "block";
  document.getElementById("toggle-rotation-controls-btn").style.display = "block";
  document.getElementById("toggle-visibility-controls-btn").style.display = "block";

  this.style.display = "none"; // Hide the main button

  document.getElementById("topic-chat-btn").style.display = "none";

  // Open the visibility controls

  return false; // Prevent any other handlers
});

document.getElementById("topic-chat-btn").addEventListener("click", (event) => {
  event.stopPropagation(); // Prevent event bubbling

  closeOptionsWithoutChat();

  if (document.getElementById("topic-chat-container").style.display === "block") {
    document.getElementById("topic-chat-container").style.display = "none";
  } else {
    document.getElementById("topic-chat-container").style.display = "block";
  }





    // Reset the toolbar state
    isToolbarOpen = true; // Ensure the toolbar state is reset

    document.getElementById("toggle-controls-btn").style.display = "none";
    document.getElementById("toggle-toolbar-btn").style.display = "none";
    document.getElementById("toggle-rotation-controls-btn").style.display = "none";
    document.getElementById("main-toggle-btn").style.display = "block";
    document.getElementById("toggle-visibility-controls-btn").style.display = "none";
    document.getElementById("visibility-controls").style.display = "none";
    return false; // Prevent any other handlers

});


// Event listener for the control buttons to hide them and show the main toggle button
const controlButtons = [
  "toggle-controls-btn",
  "toggle-toolbar-btn",
  "toggle-rotation-controls-btn",
  "toggle-visibility-controls-btn"
];

controlButtons.forEach(buttonId => {
  document.getElementById(buttonId).addEventListener("click", function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    // Hide the control buttons and show the main toggle button
    controlButtons.forEach(id => {
      document.getElementById(id).style.display = "none"; // Hide all control buttons
    });
    document.getElementById("main-toggle-btn").style.display = "block"; // Show the main button
    document.getElementById("topic-chat-btn").style.display = "block";
  });
});

// Ensure the object button is hidden initially
document.getElementById("toggle-rotation-controls-btn").style.display = "none"; // Hide initially

// Add event listener for the rotation controls toggle button
document.getElementById("toggle-rotation-controls-btn").addEventListener("click", function(e) {
  e.preventDefault();
  e.stopPropagation();
  isToolbarOpen = true;
  // Toggle the display of the rotation controls
  const rotationControls = document.getElementById("rotation-controls");
  rotationControls.style.display = 
    rotationControls.style.display === "block" ? "none" : "block"; // Toggle rotation controls
});

// Add a document click listener to close options when clicking outside
document.addEventListener("click", function(event) {
  const toggleControlsBtn = document.getElementById("toggle-controls-btn");
  const toggleToolbarBtn = document.getElementById("toggle-toolbar-btn");
  const mainToggleBtn = document.getElementById("main-toggle-btn");
  const toolbar = document.getElementById("toolbar");
  const toggleVisibilityControlsBtn = document.getElementById("toggle-visibility-controls-btn");

  // Check if the click is outside the toggle buttons and the main button
  if (
    !toggleControlsBtn.contains(event.target) &&
    !toggleToolbarBtn.contains(event.target) &&
    !mainToggleBtn.contains(event.target) &&
    !toolbar.contains(event.target) &&
    !toggleVisibilityControlsBtn.contains(event.target)
  ) {
    closeOptions();
  }
});

// Modify the existing toggle buttons to also hide themselves and show the main button
document.getElementById("toggle-controls-btn").addEventListener("click", function(event) {
    event.stopPropagation();
    closeOptions(); // Close options after toggling
});

// Fix the toggle-controls-btn click handler with more aggressive visibility controls
document.getElementById("toggle-controls-btn").addEventListener("click", function(e) {
  e.preventDefault();
  e.stopPropagation();
  
  // Get the control elements
  const zoomControls = document.getElementById("zoom-controls");
  const leftDpad = document.getElementById("left-dpad");
  const rightDpad = document.getElementById("right-dpad");
  
  // Check if they exist
  if (!zoomControls || !leftDpad || !rightDpad) {
    console.error("Control elements not found:", {zoomControls, leftDpad, rightDpad});
    return false;
  }
  
  // Log current visibility state
  const isVisible = getComputedStyle(zoomControls).display !== "none";
  
  // Toggle visibility with !important to override other styles
  if (isVisible) {
    // Hide controls
    zoomControls.setAttribute("style", "display: none !important");
    leftDpad.setAttribute("style", "display: none !important");
    rightDpad.setAttribute("style", "display: none !important");
  } else {
    // Show controls with high z-index and forced visibility
    zoomControls.setAttribute("style", "display: flex !important; z-index: 2000 !important; opacity: 1 !important; visibility: visible !important;");
    leftDpad.setAttribute("style", "display: grid !important; z-index: 2000 !important; opacity: 1 !important; visibility: visible !important;");
    rightDpad.setAttribute("style", "display: grid !important; z-index: 2000 !important; opacity: 1 !important; visibility: visible !important;");
    
    // Also make sure any parent containers are visible
    let parent = zoomControls.parentElement;
    while (parent && parent !== document.body) {
      if (getComputedStyle(parent).display === "none") {
        parent.style.display = "block";
      }
      parent = parent.parentElement;
    }
  }
  
  // Hide both toggle buttons and show the main button
  document.getElementById("toggle-controls-btn").style.display = "none";
  newToggleBtn.style.display = "none";
  document.getElementById("main-toggle-btn").style.display = "block";
  
  return false;
});

// Make sure each toggle button correctly hides itself and shows the main button when clicked
document.getElementById("toggle-controls-btn").addEventListener("click", function(e) {
  e.preventDefault();
  e.stopPropagation();
  
  // Do its primary function (toggle controls)
  const zoomControls = document.getElementById("zoom-controls");
  const leftDpad = document.getElementById("left-dpad");
  const rightDpad = document.getElementById("right-dpad");
  
  const isVisible = zoomControls.style.display === "flex";
  
  // Toggle visibility state
  if (isVisible) {
    zoomControls.style.display = "none";
    leftDpad.style.display = "none";
    rightDpad.style.display = "none";
  } else {
    zoomControls.style.display = "flex";
    leftDpad.style.display = "grid";
    rightDpad.style.display = "grid";
  }
  
  // Hide both toggle buttons and show the main button
  document.getElementById("toggle-controls-btn").style.display = "none";
  newToggleBtn.style.display = "none";
  document.getElementById("main-toggle-btn").style.display = "block";
  
  return false;
});

// Replace any existing toolbar toggle functionality
const toolbar = document.getElementById("toolbar");

// Store the original display style
const originalToolbarStyle = toolbar.style.display;

// Create and inject a completely new button
const newToggleBtn = document.createElement("button");
newToggleBtn.textContent = "Toggle Toolbar";
newToggleBtn.style.cssText = `
  position: fixed;
  top: 11vh;
  left: 0;
  z-index: 1010; /* Higher z-index to ensure visibility */
  background-color: #007bff;
  color: white;
  border: none;
  padding: 0.8vh 1vw;
  border-radius: 0.8vh;
  cursor: pointer;
  font-size: 1.5vh;
  display: none;
`;

// Insert it after the original button
const originalToggleBtn = document.getElementById("toggle-toolbar-btn");
if (originalToggleBtn && originalToggleBtn.parentNode) {
  originalToggleBtn.parentNode.insertBefore(newToggleBtn, originalToggleBtn.nextSibling);
  originalToggleBtn.style.display = "none"; // Hide the original button
}

// Add a clean click handler to the new button
newToggleBtn.addEventListener("click", function(e) {
  e.preventDefault();
  e.stopPropagation();
  
  // Toggle state
  isToolbarOpen = !isToolbarOpen;
  
  // Force display style after a slight delay (to avoid race conditions)
  setTimeout(() => {
    toolbar.style.display = isToolbarOpen ? "flex" : "none";
    console.log("Toolbar visibility forcibly set to:", isToolbarOpen);
  }, 10);
  
  // Hide the toggle buttons and show the main button
  document.getElementById("toggle-controls-btn").style.display = "none";
  newToggleBtn.style.display = "none";
  document.getElementById("main-toggle-btn").style.display = "block";
  
  return false; // Prevent any other handlers
});

// Make sure the toolbar starts hidden
window.addEventListener("load", function() {
  toolbar.style.display = "none";
  isToolbarOpen = false;
});

// Adjust the styles for each input toolbar to make them bigger
const inputToolbars = [
  "load-column",
  "marker-column",
  "polygon-column",
  "create-column",
  "memo-column",
  "rules-column",
  "stack-topic-ids",
  "edit-profile-column"
];

inputToolbars.forEach(toolbarId => {
  const toolbar = document.getElementById(toolbarId);
  const mainToolbar = document.getElementById("toolbar");
  if (toolbar && mainToolbar) {
    toolbar.style.width = "52vw";
    toolbar.style.height = `${mainToolbar.offsetHeight}px`; // Match height to the toolbar
    toolbar.style.padding = "0"; // Remove padding

    // Make input boxes inside the toolbar bigger
    const inputs = toolbar.querySelectorAll('input, textarea');
    inputs.forEach(input => {
      input.style.width = "48vw"; // Increase width to fill the toolbar
      input.style.height = "5vh"; // Increase height for better visibility
      input.style.fontSize = "2vh"; // Increase font size for readability
      input.style.marginBottom = "1vh"; // Add some space between inputs
    });
  }
});

document.addEventListener("click", (event) => {
  const toggleControlsBtn = document.getElementById("toggle-controls-btn");
  const toggleToolbarBtn = document.getElementById("toggle-toolbar-btn");
  const mainToggleBtn = document.getElementById("main-toggle-btn");
  const toolbar = document.getElementById("toolbar");

  // Check if the click is outside the toggle buttons and the toolbar
  if (
    !toggleControlsBtn.contains(event.target) &&
    !toggleToolbarBtn.contains(event.target) &&
    !mainToggleBtn.contains(event.target) &&
    !toolbar.contains(event.target)
  ) {
    // Hide the toggle buttons
    toggleControlsBtn.style.display = "none";
    toggleToolbarBtn.style.display = "none";

    // Show only the main "Options" button
    mainToggleBtn.style.display = "block";

    // Hide the toolbar
    toolbar.style.display = "none";
  }
});

// Ensure the toolbar toggle button also toggles the toolbar visibility
document.getElementById("toggle-toolbar-btn").addEventListener("click", (event) => {
  event.stopPropagation(); // Prevent the click from reaching the document listener
  const toolbar = document.getElementById("toolbar");
  toolbar.style.display = toolbar.style.display === "none" ? "flex" : "none";
});

// Add a document click listener to close options when clicking outside
document.addEventListener("click", function(event) {
  const toggleControlsBtn = document.getElementById("toggle-controls-btn");
  const toggleToolbarBtn = document.getElementById("toggle-toolbar-btn");
  const mainToggleBtn = document.getElementById("main-toggle-btn");
  const toggleVisibilityControlsBtn = document.getElementById("toggle-visibility-controls-btn");

  // Check if the click is outside the toggle buttons and the main button
  if (
    !toggleControlsBtn.contains(event.target) &&
    !toggleToolbarBtn.contains(event.target) &&
    !mainToggleBtn.contains(event.target) &&
    !toggleVisibilityControlsBtn.contains(event.target)
  ) {
    // Hide the toggle buttons
    toggleControlsBtn.style.display = "none";
    toggleToolbarBtn.style.display = "none";
    toggleVisibilityControlsBtn.style.display = "none"; // Hide the visibility controls button
    // Show only the main "Options" button
    mainToggleBtn.style.display = "block";
  }
});

document.getElementById("toggle-visibility-controls-btn").addEventListener("click", function(event) {
  event.stopPropagation(); // Prevent the click from reaching the document listener
  const visibilityControls = document.getElementById("visibility-controls");
  // Toggle visibility controls display
  visibilityControls.style.display = visibilityControls.style.display === "none" ? "block" : "none";
  isToolbarOpen = true;
});

// Add a click handler to the visibility controls itself to prevent event bubbling
document.getElementById("visibility-controls").addEventListener("click", function(event) {
  event.stopPropagation();
});

// Modify the document click handler to close visibility controls if clicked outside
document.addEventListener("click", (event) => {
  const visibilityControls = document.getElementById("visibility-controls");
  if (!visibilityControls.contains(event.target) && event.target !== document.getElementById("toggle-visibility-controls-btn")) {
    visibilityControls.style.display = "none";
  }
});


  // Add these variables to manage visibility states
  let markersVisible = false;
  let polygonsVisible = true;

  // Function to toggle markers visibility
  function toggleMarkers() {
      markersVisible = !markersVisible;
      existingMarkers.forEach(marker => {
          // Check if the marker element exists and toggle its visibility
          if (marker.getElement()) {
              if (markersVisible) {
                  marker.getElement().style.display = 'block'; // Show marker
                  marker.addTo(map); // Add marker back to the map
              } else {
                  marker.getElement().style.display = 'none'; // Hide marker
                  marker.remove(); // Remove marker from the map
              }
          }
      });
      // Update the button state text
      document.getElementById("marker-visibility-value").textContent = markersVisible ? "On" : "Off"; 
      
      // Prevent updating clusters if markers are not visible
      if (!markersVisible) {
          map.off("moveend", debouncedUpdateClusters); // Unsubscribe from moveend event
      } else {
          map.on("moveend", debouncedUpdateClusters); // Subscribe back to moveend event
      }
  }

  toggleMarkers();

  // Function to toggle polygons visibility
  function togglePolygons() {
      polygonsVisible = !polygonsVisible; // Toggle state

      polygons.forEach(polygon => {
          const layerId = `${polygon.id}-image-layer`;
          const maskLayerId = `${polygon.id}-mask-layer`; // Define the mask layer ID

          if (map.getLayer(layerId)) {
              const visibility = polygonsVisible ? 'visible' : 'none'; // Set visibility based on the current state
              map.setLayoutProperty(layerId, 'visibility', visibility);
              map.setLayoutProperty(maskLayerId, 'visibility', visibility); // Also toggle the mask layer visibility
          }
      });

      document.getElementById("polygon-visibility-value").textContent = polygonsVisible ? "On" : "Off"; // Update button state
  }

  // Add event listeners for the existing buttons
  document.getElementById("toggle-polygon-visibility").addEventListener("click", togglePolygons);

  document.getElementById("toggle-marker-visibility").addEventListener("click", () => {
      toggleMarkers(); // Call the toggle function directly
  });
    // Add this code to your existing script section
document.getElementById("color-red").addEventListener("input", (event) => {
    const value = event.target.value;
    document.getElementById("color-red-value").textContent = value; // Update displayed value
    document.getElementById("color-red-value").value = value; // Update number input
    updateColor(); // Call function to update color immediately
});

document.getElementById("color-green").addEventListener("input", (event) => {
    const value = event.target.value;
    document.getElementById("color-green-value").textContent = value; // Update displayed value
    document.getElementById("color-green-value").value = value; // Update number input
    updateColor(); // Call function to update color immediately
});

document.getElementById("color-blue").addEventListener("input", (event) => {
    const value = event.target.value;
    document.getElementById("color-blue-value").textContent = value; // Update displayed value
    document.getElementById("color-blue-value").value = value; // Update number input
    updateColor(); // Call function to update color immediately
});

// Add event listeners for number inputs to update sliders
document.getElementById("color-red-value").addEventListener("input", (event) => {
    const value = event.target.value;
    document.getElementById("color-red").value = value; // Update range input
    updateColor(); // Call function to update color immediately
});

document.getElementById("color-green-value").addEventListener("input", (event) => {
    const value = event.target.value;
    document.getElementById("color-green").value = value; // Update range input
    updateColor(); // Call function to update color immediately
});

document.getElementById("color-blue-value").addEventListener("input", (event) => {
    const value = event.target.value;
    document.getElementById("color-blue").value = value; // Update range input
    updateColor(); // Call function to update color immediately
});

// Function to update the color based on slider values
function updateColor() {
    const red = document.getElementById("color-red").value;
    const green = document.getElementById("color-green").value;
    const blue = document.getElementById("color-blue").value;

    // Construct the RGB color string
    const color = `rgb(${red}, ${green}, ${blue})`;

    // Change the color of the crosshair
    const crosshair = document.getElementById("crosshair");
    if (crosshair) {
        crosshair.style.setProperty('--crosshair-color', color);
    }
}

function updateCrosshairBeforeAfter(value) {
    const crosshair = document.getElementById("crosshair");
    crosshair.style.setProperty('--crosshair-before-width', `${value}px`); // Width of ::before
    crosshair.style.setProperty('--crosshair-after-height', `${value}px`); // Height of ::after
}

function updateCrosshairAfterBefore(value) {
    const crosshair = document.getElementById("crosshair");
    crosshair.style.setProperty('--crosshair-after-width', `${value}px`); // Width of ::after
    crosshair.style.setProperty('--crosshair-before-height', `${value}px`); // Height of ::before
}

// Add event listeners for crosshair size sliders
document.getElementById("crosshair-before-after").addEventListener("input", (event) => {
    const value = event.target.value;
    document.getElementById("crosshair-before-after-value").textContent = value;
    updateCrosshairBeforeAfter(value);
    document.getElementById("crosshair-before-after-value").value = value; // Update number input
});

document.getElementById("crosshair-after-before").addEventListener("input", (event) => {
    const value = event.target.value;
    document.getElementById("crosshair-after-before-value").textContent = value;
    updateCrosshairAfterBefore(value);
    document.getElementById("crosshair-after-before-value").value = value; // Update number input
});

// Add event listeners for number inputs to update sliders
document.getElementById("crosshair-before-after-value").addEventListener("input", (event) => {
    const value = event.target.value;
    document.getElementById("crosshair-before-after").value = value; // Update range input
    updateCrosshairBeforeAfter(value);
});

document.getElementById("crosshair-after-before-value").addEventListener("input", (event) => {
    const value = event.target.value;
    document.getElementById("crosshair-after-before").value = value; // Update range input
    updateCrosshairAfterBefore(value);
});




                  // Add event listeners for the new buttons
                  document.getElementById("savecrosshair").addEventListener("click", async (event) => {
        event.stopPropagation();

        try {
            const topicId = "0.0.9609927";

            const colorRed = document.getElementById("color-red").value;
            const colorGreen = document.getElementById("color-green").value;
            const colorBlue = document.getElementById("color-blue").value;

            const crosshairBeforeWidth = document.getElementById("crosshair-before-after").value;
            const crosshairAfterHeight = document.getElementById("crosshair-after-before").value;

            // Construct the message data
            const messageData = {
                data: {
                    color: {
                        red: colorRed,
                        green: colorGreen,
                        blue: colorBlue
                    },
                    crosshair: {
                        beforeWidth: crosshairBeforeWidth,
                        afterHeight: crosshairAfterHeight
                    }
                },
            };

            const message = JSON.stringify(messageData);

            const receipt = await window.HashinalsWalletConnectSDK.submitMessageToTopic(
                topicId,
                message
            );
            console.log("Profile settings updated successfully:", receipt);
            
        } catch (error) {
            console.error("Error updating settings picture:", error);
            // Removed alert
        }
      });



      async function loadProfileCrosshair() {
        const topicId = "0.0.9609927";
        const accountObjectSettings = []; // Initialize an empty array to store account Settings
        try {
            const result = await window.HashinalsWalletConnectSDK.getMessages(topicId);

            // Check if result exists and has messages
            if (!result || !Array.isArray(result.messages) || result.messages.length === 0) {
                return accountObjectSettings; // Return empty array if no messages
            }

            // Filter messages to find those from the current user
            const userMessages = result.messages.filter(message => message.payer === globalAccountId);

            // Get the last message from the filtered user messages
            const lastMessage = userMessages[userMessages.length - 1];

            // Check if the last message has valid data
            if (lastMessage && lastMessage.data) {

                // Extract relevant data
                const { rotation, position, color, scale, crosshair } = lastMessage.data;

                // Store the settings in accountObjectSettings
                accountObjectSettings.push({
                    color,
                    crosshair
                });

                document.getElementById("color-red").value = color.red; // Set color red
                document.getElementById("color-red-value").value = color.red; // Set color red value
                document.getElementById("color-green").value = color.green; // Set color green
                document.getElementById("color-green-value").value = color.green; // Set color green value
                document.getElementById("color-blue").value = color.blue; // Set color blue
                document.getElementById("color-blue-value").value = color.blue; // Set color blue value

                document.getElementById("crosshair-before-after").value = crosshair.beforeWidth; // Set crosshair before width
                document.getElementById("crosshair-before-after-value").value = crosshair.beforeWidth; // Set crosshair before width value
                document.getElementById("crosshair-after-before").value = crosshair.afterHeight; // Set crosshair after height
                document.getElementById("crosshair-after-before-value").value = crosshair.afterHeight; // Set crosshair after height value

                // Call update functions to apply the loaded values
                updateColor(); // Update crosshair color
                updateCrosshairBeforeAfter(crosshair.beforeWidth); // Update crosshair before width
                updateCrosshairAfterBefore(crosshair.afterHeight); // Update crosshair after height

            } else {
                console.log("Last message does not have valid data."); // Log invalid data
            }

            return accountObjectSettings; // Return the populated array

        } catch (error) {
            console.log("Error in loadProfileCrosshair:", error);
            return []; // Return empty array instead of throwing error
        }
      }



            // Add event listeners for the new buttons
            document.getElementById("buttonforobject").addEventListener("click", async (event) => {
        event.stopPropagation();
        const inputValue = document.getElementById("object-input").value;
        
        try {
          const topicId = "0.0.9609898";
          const cleanUrl = inputValue.replace(/\?network=mainnet$/, "");

          const messageData = {
            data: {
              settings: [],
              urls: [cleanUrl],
            },
          };
          const message = JSON.stringify(messageData);

          const receipt = await window.HashinalsWalletConnectSDK.submitMessageToTopic(
            topicId,
            message
          );
          console.log("Profile picture updated successfully:", receipt);
          
          document.getElementById("object-input").value = "";
          
        } catch (error) {
          console.error("Error updating profile picture:", error);
          // Removed alert
        }
      });


                        // Add event listeners for the new buttons
                        document.getElementById("savesettings").addEventListener("click", async (event) => {
        event.stopPropagation();

        try {
            const topicId = "0.0.9609898";
            const profileObjectUrl = await loadProfileObject();
            const cleanUrl = (profileObjectUrl.length > 0 ? profileObjectUrl[0].replace(/\?network=mainnet$/, "") : defaultModelUrl);

            // Read values from inputs
            const rotationX = document.getElementById("rotation-x").value;
            const rotationY = document.getElementById("rotation-y").value;
            const rotationZ = document.getElementById("rotation-z").value;

            const positionX = document.getElementById("position-x").value;
            const positionY = document.getElementById("position-y").value;
            const positionZ = document.getElementById("position-z").value;

            const scaleFactor = document.getElementById("scale-factor").value;

            // Construct the message data
            const messageData = {
                data: {
                    settings : {
                      rotation: {
                        x: rotationX,
                        y: rotationY,
                        z: rotationZ
                    },
                    position: {
                        x: positionX,
                        y: positionY,
                        z: positionZ
                    },
                    scale: {
                      scaleFactor
                    },
                },
                urls: [cleanUrl],
              },
            };

            const message = JSON.stringify(messageData);

            const receipt = await window.HashinalsWalletConnectSDK.submitMessageToTopic(
                topicId,
                message
            );
            console.log("Profile settings updated successfully:", receipt);
            
        } catch (error) {
            console.error("Error updating settings picture:", error);
            // Removed alert
        }
      });

      async function loadProfileObject() {
        
        const topicId = "0.0.9609898";
        const accountObjectUrl = []; // Initialize an empty array to store account URLs
        try {
            const result = await window.HashinalsWalletConnectSDK.getMessages(topicId);

            // Check if result exists and has messages
            if (!result || !Array.isArray(result.messages) || result.messages.length === 0) {
                console.log("No profile object found, using defaults");
                return accountObjectUrl; // Return empty array if no messages
            }

            // Filter messages to find those from the current user
            const userMessages = result.messages.filter(message => message.payer === globalAccountId);

            // Get the last message from the filtered user messages
            const lastMessage = userMessages[userMessages.length - 1];

            // Check if the last message has valid data
            if (lastMessage && lastMessage.data && lastMessage.data.urls && lastMessage.data.urls.length > 0) {
                // Store the URL for this account
                accountObjectUrl.push(lastMessage.data.urls[0]); // Accessing the first URL
            }

            return accountObjectUrl; // Return the populated array

        } catch (error) {
            console.log("Error in loadProfileObject:", error);
            return []; // Return empty array instead of throwing error
        }
      }

    

      async function loadProfileSettings() {
        const topicId = "0.0.9609898";
        const accountObjectSettings = []; // Initialize an empty array to store account Settings
        try {
            const result = await window.HashinalsWalletConnectSDK.getMessages(topicId);

            // Check if result exists and has messages
            if (!result || !Array.isArray(result.messages) || result.messages.length === 0) {
                return accountObjectSettings; // Return empty array if no messages
            }

            // Filter messages to find those from the current user
            const userMessages = result.messages.filter(message => message.payer === globalAccountId);

            // Get the last message from the filtered user messages
            const lastMessage = userMessages[userMessages.length - 1];

            // Check if the last message has valid data
            if (lastMessage && lastMessage.data) {
              
              // Check if settings are empty
              if (Array.isArray(lastMessage.data.settings) && lastMessage.data.settings.length === 0) {
                const urls = lastMessage.data.urls; // This will give you the entire array
                // Store the settings in accountObjectSettings
                accountObjectSettings.push({ urls });
              } else {
                // Extract relevant data
                const { rotation, position, scale } = lastMessage.data.settings;
                const urls = lastMessage.data.urls; // This will give you the entire array

                // Store the settings in accountObjectSettings
                accountObjectSettings.push({ rotation, position, scale, urls });

                // Update input fields with the extracted data
                document.getElementById("rotation-x").value = rotation.x; // Set rotation X
                document.getElementById("rotation-x-value").value = rotation.x; // Set rotation X value
                document.getElementById("rotation-y").value = rotation.y; // Set rotation Y
                document.getElementById("rotation-y-value").value = rotation.y; // Set rotation Y value
                document.getElementById("rotation-z").value = rotation.z; // Set rotation Z
                document.getElementById("rotation-z-value").value = rotation.z; // Set rotation Z value

                document.getElementById("position-x").value = position.x; // Set position X
                document.getElementById("position-x-value").value = position.x; // Set position X value
                document.getElementById("position-y").value = position.y; // Set position Y
                document.getElementById("position-y-value").value = position.y; // Set position Y value
                document.getElementById("position-z").value = position.z; // Set position Z
                document.getElementById("position-z-value").value = position.z; // Set position Z value

                // Add scale factor input update
                document.getElementById("scale-factor").value = scale.scaleFactor; // Update scale factor input
                document.getElementById("scale-factor-value").value = scale.scaleFactor; // Update scale factor value

                // Update the object's position and rotation
                const ufoModel = scene.getObjectByName('gltfModel'); // Assuming the UFO model is named 'ufo'
                if (ufoModel) {
                    ufoModel.rotation.x = THREE.MathUtils.degToRad(rotation.x);
                    ufoModel.rotation.y = THREE.MathUtils.degToRad(rotation.y);
                    ufoModel.rotation.z = THREE.MathUtils.degToRad(rotation.z);
                    ufoModel.position.set(position.x, position.y, position.z);
                    ufoModel.scale.set(scale.scaleFactor, scale.scaleFactor, scale.scaleFactor); // Scale the model
                }
              }
            } else {
              console.log("Last message does not have valid data."); // Log invalid data
            }

                      // Check if accountObjectSettings is empty and set default model URL
                      if (accountObjectSettings.length === 0) {
                await loadUfoModel(defaultModelUrl); // Load the default model
            }

            return accountObjectSettings; // Return the populated array
        } catch (error) {
            console.log("Error in loadProfileSettings:", error);
            return []; // Return empty array instead of throwing error
        }
      }

async function loadUfoModel(modelUrl) {

    // Check if the model URL is defined and valid
    if (!modelUrl || typeof modelUrl !== 'string' || modelUrl.trim() === '') {
        modelUrl = defaultModelUrl; // Use the default model URL
        console.log('Using default model URL:', modelUrl);

    }

    // Load the GLTF model
    try {
        // Remove the previous model if it exists
        if (currentUfoModel) {
            scene.remove(currentUfoModel);
            currentUfoModel = null; // Clear the reference to the removed model
        }

        const gltf = await new Promise((resolve, reject) => {
            ufoLoader.load(modelUrl, resolve, undefined, (error) => {
                console.error("Error loading GLTF model:", error);
                reject(error);
            });
        });
        
        currentUfoModel = gltf.scene; // Get the loaded model

        // Step 1: Calculate the model's bounding box
        const box = new THREE.Box3().setFromObject(currentUfoModel);
        const modelSize = new THREE.Vector3();
        box.getSize(modelSize); // Get the size of the model

        // Step 2: Define the bounding box dimensions
        const boundingBoxSize = new THREE.Vector3(10, 10, 10); // Width, Height, Depth

        // Step 3: Calculate the scale factor
        const scaleFactor = Math.min(
            boundingBoxSize.x / modelSize.x,
            boundingBoxSize.y / modelSize.y,
            boundingBoxSize.z / modelSize.z
        );

        // Step 4: Apply the scale to the model
        currentUfoModel.scale.set(scaleFactor, scaleFactor, scaleFactor); // Scale the model uniformly

        const isNewUser = modelUrl === defaultModelUrl; // Set to true if no URLs are found

        // Check if the user has loaded their profile object
        if (modelUrl !== defaultModelUrl) {
            // Load user-specific settings if available
            const profileSettings = await loadProfileSettings(); // Load profile settings
            if (profileSettings.length === 0 || !profileSettings[0].position) {
                // If no settings loaded, use bounding box for position
                currentUfoModel.position.set(box.min.x, box.min.y, box.min.z); // Use bounding box min for position
                currentUfoModel.scale.set(scaleFactor, scaleFactor, scaleFactor); // Use calculated scale factor
                // Step 5: Position the model within the bounding box
                currentUfoModel.position.set(0, -5, -30); // Adjust as needed
            } else {
                // Apply user-specific settings
                currentUfoModel.position.set(
                    parseFloat(document.getElementById("position-x").value),
                    parseFloat(document.getElementById("position-y").value),
                    parseFloat(document.getElementById("position-z").value)
                );
                currentUfoModel.rotation.set(
                    THREE.MathUtils.degToRad(document.getElementById("rotation-x").value),
                    THREE.MathUtils.degToRad(document.getElementById("rotation-y").value),
                    THREE.MathUtils.degToRad(document.getElementById("rotation-z").value)
                );
                const userScaleFactor = parseFloat(document.getElementById("scale-factor").value);
                currentUfoModel.scale.set(userScaleFactor, userScaleFactor, userScaleFactor); // Scale the model uniformly
            }
        } else {
            // Default settings for new users
            currentUfoModel.position.set(0, -3, -8); // Default position
            currentUfoModel.rotation.set(
                THREE.MathUtils.degToRad(0),
                THREE.MathUtils.degToRad(90),
                THREE.MathUtils.degToRad(45)
            ); // Default rotation
            const defaultScaleFactor = 20; // Default scale factor
            currentUfoModel.scale.set(defaultScaleFactor, defaultScaleFactor, defaultScaleFactor); // Scale the model uniformly
        }

        // Add the model to the scene
        scene.add(currentUfoModel);

        // Existing event listeners for rotation and position sliders
        document.getElementById("rotation-x").addEventListener("input", (event) => {
            const value = event.target.value;
            document.getElementById("rotation-x-value").value = value; // Update number input
            currentUfoModel.rotation.x = THREE.MathUtils.degToRad(value); // Convert degrees to radians
        });

        document.getElementById("rotation-y").addEventListener("input", (event) => {
            const value = event.target.value;
            document.getElementById("rotation-y-value").value = value; // Update number input
            currentUfoModel.rotation.y = THREE.MathUtils.degToRad(value); // Convert degrees to radians
        });

        document.getElementById("rotation-z").addEventListener("input", (event) => {
            const value = event.target.value;
            document.getElementById("rotation-z-value").value = value; // Update number input
            currentUfoModel.rotation.z = THREE.MathUtils.degToRad(value); // Convert degrees to radians
        });

        // Add event listeners for position sliders
        document.getElementById("position-x").addEventListener("input", (event) => {
            const value = event.target.value;
            document.getElementById("position-x-value").value = value; // Update number input
            currentUfoModel.position.x = parseFloat(value); // Update the x position of the model
        });

        document.getElementById("position-y").addEventListener("input", (event) => {
            const value = event.target.value;
            document.getElementById("position-y-value").value = value; // Update number input
            currentUfoModel.position.y = parseFloat(value); // Update the y position of the model
        });

        // Add Z position slider
        document.getElementById("position-z").addEventListener("input", (event) => {
            const value = event.target.value;
            document.getElementById("position-z-value").value = value; // Update number input
            currentUfoModel.position.z = parseFloat(value); // Update the z position of the model
        });

        // Add scale factor slider
        document.getElementById("scale-factor").addEventListener("input", (event) => {
            const value = event.target.value;
            document.getElementById("scale-factor-value").value = value; // Update number input
            const scaleFactor = parseFloat(value); // Get the scale factor
            currentUfoModel.scale.set(scaleFactor, scaleFactor, scaleFactor); // Scale the model uniformly
        });

        // Add event listeners for number inputs to update sliders
        document.getElementById("rotation-x-value").addEventListener("input", (event) => {
            const value = event.target.value;
            document.getElementById("rotation-x").value = value; // Update range input
            currentUfoModel.rotation.x = THREE.MathUtils.degToRad(value); // Convert degrees to radians
        });

        document.getElementById("rotation-y-value").addEventListener("input", (event) => {
            const value = event.target.value;
            document.getElementById("rotation-y").value = value; // Update range input
            currentUfoModel.rotation.y = THREE.MathUtils.degToRad(value); // Convert degrees to radians
        });

        document.getElementById("rotation-z-value").addEventListener("input", (event) => {
            const value = event.target.value;
            document.getElementById("rotation-z").value = value; // Update range input
            currentUfoModel.rotation.z = THREE.MathUtils.degToRad(value); // Convert degrees to radians
        });

        document.getElementById("position-x-value").addEventListener("input", (event) => {
            const value = event.target.value;
            document.getElementById("position-x").value = value; // Update range input
            currentUfoModel.position.x = parseFloat(value); // Update the x position of the model
        });

        document.getElementById("position-y-value").addEventListener("input", (event) => {
            const value = event.target.value;
            document.getElementById("position-y").value = value; // Update range input
            currentUfoModel.position.y = parseFloat(value); // Update the y position of the model
        });

        document.getElementById("position-z-value").addEventListener("input", (event) => {
            const value = event.target.value;
            document.getElementById("position-z").value = value; // Update range input
            currentUfoModel.position.z = parseFloat(value); // Update the z position of the model
        });

        document.getElementById("scale-factor-value").addEventListener("input", (event) => {
            const value = event.target.value;
            document.getElementById("scale-factor").value = value; // Update range input
            const scaleFactor = parseFloat(value); // Get the scale factor
            currentUfoModel.scale.set(scaleFactor, scaleFactor, scaleFactor); // Scale the model uniformly
        });

        // Load current values into input fields after model is loaded
        document.getElementById("position-x").value = currentUfoModel.position.x;
        document.getElementById("position-y").value = currentUfoModel.position.y;
        document.getElementById("position-z").value = currentUfoModel.position.z;
        document.getElementById("scale-factor").value = currentUfoModel.scale.x; // Assuming uniform scaling
        document.getElementById("position-x-value").value = currentUfoModel.position.x;
        document.getElementById("position-y-value").value = currentUfoModel.position.y;
        document.getElementById("position-z-value").value = currentUfoModel.position.z;

        // Convert radians to degrees for display
        const rotationXInDegrees = THREE.MathUtils.radToDeg(currentUfoModel.rotation.x);
        const rotationYInDegrees = THREE.MathUtils.radToDeg(currentUfoModel.rotation.y);
        const rotationZInDegrees = THREE.MathUtils.radToDeg(currentUfoModel.rotation.z);

        document.getElementById("rotation-x").value = Math.round(rotationXInDegrees); // Round to nearest integer
        document.getElementById("rotation-y").value = Math.round(rotationYInDegrees); // Round to nearest integer
        document.getElementById("rotation-z").value = Math.round(rotationZInDegrees); // Round to nearest integer

        document.getElementById("rotation-x-value").value = Math.round(rotationXInDegrees);
        document.getElementById("rotation-y-value").value = Math.round(rotationYInDegrees);
        document.getElementById("rotation-z-value").value = Math.round(rotationZInDegrees);
        document.getElementById("scale-factor-value").value = currentUfoModel.scale.x;

    } catch (error) {
        console.error('An error occurred while loading the GLTF model:', error);
    }
}
loader.updateProgress();
const toolbarColumns = document.querySelectorAll('.toolbar-column');

toolbarColumns.forEach(column => {
  column.addEventListener('touchstart', () => {
    column.classList.add('active'); // Add active class on touch
  });

  column.addEventListener('touchend', () => {
    column.classList.remove('active'); // Remove active class on touch end
  });
});

document.getElementById("load-topic-rules-for-marker").addEventListener("click", async () => {
    try {
      let userInput = document.getElementById("input-field-2-0").value.toLowerCase();
              let domainEntry = loadedDomains.find(entry => entry.domain === userInput);
              let topicId;

              if (domainEntry && domainEntry.lastMessage) {
                topicId = domainEntry.lastMessage.topic;
              } else {
                topicId = userInput;
              }
      const response = await window.HashinalsWalletConnectSDK.getMessages(topicId);
      const topicInfo = await sdk.getTopicInfo(topicId);
      const topicAdmin = [];
      let hasRules = false;
      const memo = topicInfo.memo;

      // Split the memo by commas
      const parts = memo.split(',');

      // Iterate over each part
      parts.forEach(part => {
        // Check if the part starts with "0.0."
        if (part.startsWith("0.0.")) {
          // Add it to the topicAdmin array
          topicAdmin.push(part);
          hasRules = true;
        }
      });

      // Check if messages exist and is an array
      if (!response.messages || !Array.isArray(response.messages)) {
        console.error(`No messages found for topic ${topicId}.`, response);
      }

      const messages = response.messages; // Extract messages

      const loadedTopicRulesForMarker = [];

      // Read rules from messages
      for (let index = messages.length - 1; index >= 0; index--) {
        const message = messages[index];
        try {
          let parsedMessage = message;
          if (typeof message === 'string') {
            parsedMessage = JSON.parse(message);
          }
          if (parsedMessage.rules && (topicAdmin.length === 0 || topicAdmin.includes(message.payer))) {
            loadedTopicRulesForMarker.push(parsedMessage.rules.formarker);
            hasRules = true;
            break; // Exit the loop after finding the last message with rules
          }
        } catch (messageError) {
          console.error(`Error processing message ${index}:`, messageError);
        }
      }
      console.log(loadedTopicRulesForMarker);



const markerRulesMessage = `You have to own ${loadedTopicRulesForMarker[0].markerTopicId} to show ${loadedTopicRulesForMarker[0].markerMessagesPerNft} messages per NFT.`;
document.getElementById("loaded-topic-rules-for-marker").textContent = markerRulesMessage;
adjustTextareaHeight(document.getElementById("loaded-topic-rules-for-marker"));



    } catch (error) {
      console.error("Error creating topic:", error);
    }
});




document.getElementById("load-topic-rules-for-polygon").addEventListener("click", async () => {
    try {
      let userInput = document.getElementById("input-field-3-0").value.toLowerCase();
              let domainEntry = loadedDomains.find(entry => entry.domain === userInput);
              let topicId;

              if (domainEntry && domainEntry.lastMessage) {
                topicId = domainEntry.lastMessage.topic;
              } else {
                topicId = userInput;
              }
      const response = await window.HashinalsWalletConnectSDK.getMessages(topicId);
      const topicInfo = await sdk.getTopicInfo(topicId);
      const topicAdmin = [];
      let hasRules = false;
      const memo = topicInfo.memo;

      // Split the memo by commas
      const parts = memo.split(',');

      // Iterate over each part
      parts.forEach(part => {
        // Check if the part starts with "0.0."
        if (part.startsWith("0.0.")) {
          // Add it to the topicAdmin array
          topicAdmin.push(part);
          hasRules = true;
        }
      });

      // Check if messages exist and is an array
      if (!response.messages || !Array.isArray(response.messages)) {
        console.error(`No messages found for topic ${topicId}.`, response);
      }

      const messages = response.messages; // Extract messages

      const loadedTopicRulesForPolygon = [];

      // Read rules from messages
      for (let index = messages.length - 1; index >= 0; index--) {
        const message = messages[index];
        try {
          let parsedMessage = message;
          if (typeof message === 'string') {
            parsedMessage = JSON.parse(message);
          }
          if (parsedMessage.rules && (topicAdmin.length === 0 || topicAdmin.includes(message.payer))) {
            loadedTopicRulesForPolygon.push(parsedMessage.rules.forpolygon);
            hasRules = true;
            break; // Exit the loop after finding the last message with rules
          }
        } catch (messageError) {
          console.error(`Error processing message ${index}:`, messageError);
        }
      }
      console.log(loadedTopicRulesForPolygon);



const polygonRulesMessage = `You have to own NFT ${loadedTopicRulesForPolygon[0].polygonTopicId} to show ${loadedTopicRulesForPolygon[0].polygonMessagesPerNft} messages per NFT.`;

const polygonSize = loadedTopicRulesForPolygon[0].polygonSize;
const maxLongitudeSize = 360 / polygonSize;
const maxLatitudeSize = 180 / polygonSize;

const polygonRulesMessages = `Maximum distance between points is ${maxLongitudeSize} for longitude and ${maxLatitudeSize} for latitude. If not = wont load.`;

document.getElementById("loaded-topic-rules-for-polygon").textContent = `${polygonRulesMessage}\n${polygonRulesMessages}`;
adjustTextareaHeight(document.getElementById("loaded-topic-rules-for-polygon"));



    } catch (error) {
      console.error("Error creating topic:", error);
    }
});




function isValidUrl(url) {
    try {
        new URL(url);
        return true;
    } catch {
        return false;
    }
}




async function processTopicMessages(topicId) {
        const topicGeojsonFeatures = []; // Store geojson features for this topic
        const topicPolygons = []; // Store polygons for this topic
        let loadedTopicName = ''; // Initialize loadedTopicName
        const profilePics = await loadProfilePicture();
        const usernames = await loadUsername();
      
        try {
          const response = await window.HashinalsWalletConnectSDK.getMessages(topicId);

          const topicInfo = await sdk.getTopicInfo(topicId);
          const topicAdmin = [];
          let hasRulesForMarker = false;
          let hasRulesForPolygon = false;
          const memo = topicInfo.memo;

          // Split the memo by commas
          const parts = memo.split(',');

          // Iterate over each part
          parts.forEach(part => {
            // Check if the part starts with "0.0."
            if (part.startsWith("0.0.")) {
              // Add it to the topicAdmin array
              topicAdmin.push(part);
            }
          });

          
      
          // Check if messages exist and is an array
          if (!response.messages || !Array.isArray(response.messages)) {
            console.error(`No messages found for topic ${topicId}.`, response);
            return { topicGeojsonFeatures, topicPolygons }; // Return empty arrays
          }
      
          const messages = response.messages; // Extract messages
      
          const loadedTopicRulesForMarker = [];
          const loadedTopicRulesForPolygon = [];
  

      
          // Read rules from messages
          for (let index = messages.length - 1; index >= 0; index--) {
            const message = messages[index];
            try {
              let parsedMessage = message;
              if (typeof message === 'string') {
                parsedMessage = JSON.parse(message);
              }

              if (parsedMessage.rules && (topicAdmin.length === 0 || topicAdmin.includes(message.payer))) {
                if (parsedMessage.rules.formarker.markerTopicId.startsWith('0.0.') && (topicAdmin.length === 0 || topicAdmin.includes(message.payer))) {
                loadedTopicRulesForMarker.push(parsedMessage.rules.formarker);
                hasRulesForMarker = true;

              }
              if (parsedMessage.rules.forpolygon.polygonTopicId.startsWith('0.0.') && (topicAdmin.length === 0 || topicAdmin.includes(message.payer))) {
                loadedTopicRulesForPolygon.push(parsedMessage.rules.forpolygon);
                hasRulesForPolygon = true;

              }
                break; // Exit the loop after finding the last message with rules
              }
            } catch (messageError) {
              console.error(`Error processing message ${index}:`, messageError);
            }
          }

          for (let index = messages.length - 1; index >= 0; index--) {
            const message = messages[index];
            try {
              let parsedMessage = message;
              if (typeof message === 'string') {
                parsedMessage = JSON.parse(message);
              }
              // Check if changeName exists and either topicAdmin is empty or includes the payer
              if (parsedMessage.changeName && (topicAdmin.length === 0 || topicAdmin.includes(message.payer))) {
                loadedTopicName = parsedMessage.changeName;
                break; // Stop after finding the first valid message
              }
            } catch (messageError) {
              console.error(`Error processing message ${index}:`, messageError);
            }
          }      
          const uniquePayerIdsForMarker = new Set();
          const uniquePayerIdsForPolygon = new Set();
      
          // Extract payer IDs from messages
      for (const message of messages) {
        try {
          let parsedMessage = message;
          if (typeof message === 'string') {
            parsedMessage = JSON.parse(message);
          }
      
          // Add payer IDs for markers
          if (parsedMessage.marker && parsedMessage.marker.data) {
            uniquePayerIdsForMarker.add(parsedMessage.payer);
          }
      
          // Add payer IDs for polygons
          if (parsedMessage.polygon && parsedMessage.polygon.data) {
            uniquePayerIdsForPolygon.add(parsedMessage.payer);
          }

          if (parsedMessage.addTopicNFT && (topicAdmin.length === 0 || topicAdmin.includes(message.payer))) {
          const nfts = parsedMessage.addTopicNFT.split(',').map(nft => nft.trim());
          nfts.forEach(nft => {
            if (!loadedNFTsForModel.includes(nft)) {
              loadedNFTsForModel.push(nft);
            }
          });
          }

          if (parsedMessage.removeTopicNFT && (topicAdmin.length === 0 || topicAdmin.includes(message.payer))) {
            const nft = parsedMessage.removeTopicNFT.trim();
            const index = loadedNFTsForModel.indexOf(nft);
            if (index !== -1) {
              loadedNFTsForModel.splice(index, 1);
            }
          }

        if (parsedMessage.addScale && (topicAdmin.length === 0 || topicAdmin.includes(message.payer))) {
          const { NFT, scale } = parsedMessage.addScale;
          loadedNFTScaleForModel.push({ NFT, scale });
        }

        if (parsedMessage.removeScale && (topicAdmin.length === 0 || topicAdmin.includes(message.payer))) {
          const { NFT } = parsedMessage.removeScale;
          const index = loadedNFTScaleForModel.findIndex(item => item.NFT === NFT);
          if (index !== -1) {
            loadedNFTScaleForModel.splice(index, 1); // Remove the item if it exists
          } else {
            console.log(`NFT: ${NFT} not found in addScale list`);
          }
        }

        updateRulesForModelNFTState();

        } catch (error) {
          console.error("Error extracting payer ID:", error);
        }
      }
      
          // Ownership logic
          const markerOwnershipArray = [];
          const polygonOwnershipArray = [];

      
          if (hasRulesForMarker) {
            // Iterate over each unique payer ID for markers
            for (const payerId of uniquePayerIdsForMarker) {
              const tokenIdForMarker = loadedTopicRulesForMarker[0].markerTopicId;
              const filteredNftsForMarker = await sdk.getAccountNFTs(payerId, tokenIdForMarker);
      
              // Check if the user owns NFTs and push to an array
              if (filteredNftsForMarker.length > 0) {
                const numberOfMessages = filteredNftsForMarker.length * loadedTopicRulesForMarker[0].markerMessagesPerNft;
                const numberOfMessagesForMarker = [];
                markerOwnershipArray.push({ payerId, numberOfMessages, numberOfMessagesForMarker });
              }
            }
          }
          
          if (hasRulesForPolygon) {
      
            // Iterate over each unique payer ID for polygons
            for (const payerId of uniquePayerIdsForPolygon) {
              const tokenIdForPoly = loadedTopicRulesForPolygon[0].polygonTopicId;
              const filteredNftsForPoly = await sdk.getAccountNFTs(payerId, tokenIdForPoly);
      
              // Check if the user owns NFTs and push to an array
              if (filteredNftsForPoly.length > 0) {
                const numberOfMessages = filteredNftsForPoly.length * loadedTopicRulesForPolygon[0].polygonMessagesPerNft;
                const numberOfMessagesForPolygon = [];
                polygonOwnershipArray.push({ payerId, numberOfMessages, numberOfMessagesForPolygon });
              }
            }
          }

          if (!hasRulesForMarker) {
          for (const payerId of uniquePayerIdsForMarker) {
            const numberOfMessagesForMarker = [];
            markerOwnershipArray.push({ payerId, numberOfMessagesForMarker });
          }
        }
        if (!hasRulesForPolygon) {
          for (const payerId of uniquePayerIdsForPolygon) {
            const numberOfMessagesForPolygon = [];
            polygonOwnershipArray.push({ payerId, numberOfMessagesForPolygon });
          }
        }
          // Process each message
          for (let index = messages.length - 1; index >= 0; index--) {
            const message = messages[index];
            try {
              let parsedMessage = message;
              if (typeof message === 'string') {
                parsedMessage = JSON.parse(message);
              }
      
              const defaultProfilePic = "https://kiloscribe.com/api/inscription-cdn/0.0.4819119";
              const profileUrl = isValidUrl(message.payer && profilePics[message.payer] ? 
                profilePics[message.payer].url : 
                defaultProfilePic) ? 
                (message.payer && profilePics[message.payer] ? profilePics[message.payer].url : defaultProfilePic) : 
                defaultProfilePic;
              
              const payerInfo = message.payer ? `${message.payer}` : 'Anonymous';
              const username = message.payer && usernames[message.payer] ? 
                ` ${usernames[message.payer].username}` : 
                '';
              
              // Combine username and payerInfo with h2 tags
              const displayHeader = `<h2>${payerInfo}<br>${username}</h2>`;
      
              // Handle marker type messages
              if (parsedMessage.marker && parsedMessage.marker.data) {
                const markerOwner = markerOwnershipArray.find(owner => owner.payerId === message.payer);
                const markernumber = parsedMessage.marker.data.numberOfMarker;

                if (markernumber === undefined || markernumber === null || !Number.isInteger(Number(markernumber))) {
                continue;
              }

                if (!markerOwner.numberOfMessagesForMarker.includes(markernumber)) {
                  markerOwner.numberOfMessagesForMarker.push(markernumber);




                if (!hasRulesForMarker || (markerOwner && markerOwner.numberOfMessages > 0)) {

                  
                  
                  if (hasRulesForMarker) {
                    markerOwner.numberOfMessages -= 1;
                  }
                  
                  let coords;
                  try {
                    const cordData = parsedMessage.marker.data.cord;
                    
                    if (typeof cordData === 'string') {
                      coords = cordData.split(',').map(num => parseFloat(num.trim()));
                    } else if (Array.isArray(cordData)) {
                      coords = cordData;
                    } else {
                      throw new Error('Unsupported coordinate format');
                    }
                    
                    if (!Array.isArray(coords) || coords.length !== 2 || coords.some(isNaN)) {
                      throw new Error('Invalid coordinate format');
                    }

                    
      
                    topicGeojsonFeatures.push({
                      type: "Feature",
                      payer: message.payer,
                      properties: {
                        message: 
    `
      <div style="position: absolute; top: -0.1em; left: 0.1em; font-weight: bold;">${parsedMessage.marker.data.numberOfMarker}</div> <!-- Display number of markers -->
      <div style="display: flex; align-items: center;">
        <img src="${profileUrl}" 
        // alt="Profile photo style" 
        // style="width: 7vh; height: 7vh; margin-right: 1em; border-radius: 50%">
        <div>${displayHeader}</div>
      </div>
      <div style="text-align: center;"> <!-- Center the title -->
        <div style='margin-bottom: 1vh;'>
            <strong>${parsedMessage.marker.data.title}</strong>
        </div>
        <div>
          ${isValidUrl(parsedMessage.marker.data.image) ? `<img src="${parsedMessage.marker.data.image}" style="width: 20vh; height: 20vh; display: block; margin: 0 auto;" />` : ''} <!-- Center the image -->
        </div> 
        <div>
          <p>${parsedMessage.marker.data.msg}</p>
        </div>
      </div>
    `,
    imageUrl: isValidUrl(parsedMessage.marker.data.coverimage) ? parsedMessage.marker.data.coverimage : profileUrl
  },
                      geometry: {
                        type: "Point",
                        coordinates: coords
                      }
                    });
                  } catch (coordError) {
                    console.error("Error parsing marker coordinates:", coordError, "Raw coords:", parsedMessage.marker.data.cord);
                  }
                }
              }
            }
      
              // Handle polygon type messages
              if (parsedMessage.polygon && parsedMessage.polygon.data) {
                const polygonOwner = polygonOwnershipArray.find(owner => owner.payerId === message.payer) ;
                const polygonnumber = parsedMessage.polygon.data.numberOfPolygon;

                if (polygonnumber === undefined || polygonnumber === null || !Number.isInteger(Number(polygonnumber))) {
                  continue;
                }

                if (!polygonOwner.numberOfMessagesForPolygon.includes(polygonnumber)) {
                  polygonOwner.numberOfMessagesForPolygon.push(polygonnumber);  


                if (!hasRulesForPolygon || (polygonOwner && polygonOwner.numberOfMessages > 0)) {
                  if (hasRulesForPolygon) {
                    polygonOwner.numberOfMessages -= 1;
                  }
      
                  try {
                    const cordStr = parsedMessage.polygon.data.cord;
      
                    // Validate the coordinate string format
                    const validCoordPattern = /^\[-?\d+\.?\d*,\s*-?\d+\.?\d*\](,\s*\[-?\d+\.?\d*,\s*-?\d+\.?\d*\])*$/;
                    if (!validCoordPattern.test(cordStr)) {
                      continue; // Skip processing this message
                    }
      
                    // Parse the coordinates
                    const coordinates = JSON.parse(`[${cordStr}]`); // Wrap in brackets for valid JSON
      
                    if (Array.isArray(coordinates) && coordinates.length > 2) {
                      const polygonSize = hasRulesForPolygon ? loadedTopicRulesForPolygon[0].polygonSize : 1;      

      
    
      
                        topicPolygons.push({
                          id: `
                          polygon-${index}`,
                          payer: message.payer,
                          coordinates: [coordinates],
                          description: `
          <div style="position: absolute; top: -0.1em; left: 0.1em; font-weight: bold;">${parsedMessage.polygon.data.numberOfPolygon}</div> 
          <div style="display: flex; align-items: center;">
            <img src="${profileUrl}" 
            // alt="Profile photo style" 
            // style="width: 7vh; height: 7vh; margin-right: 1em; border-radius: 50%">
            <div>${displayHeader}</div>
          </div>
          <div style="text-align: center;"> <!-- Center the title and image -->
            <div style='margin-bottom: 1vh;'>
                <strong>${parsedMessage.polygon.data.title}</strong>
            </div>
            <div>
                    ${isValidUrl(parsedMessage.polygon.data.image) ? `<img src="${parsedMessage.polygon.data.image}" style="width: 20vh; height: 20vh; display: block; margin: 0 auto;" />` : ''} <!-- Center the image -->
            </div>
            <div>
              <p>${parsedMessage.polygon.data.msg}</p>
            </div>
          </div>
                          `,
                          imageUrl: isValidUrl(parsedMessage.polygon.data.coverimage) ? parsedMessage.polygon.data.coverimage : profileUrl
                        });
      
                      
                    } 
                  } catch (polygonError) {
                    console.error("Error parsing polygon data:", polygonError);
                  }
                }
              }
            }
            } catch (messageError) {
              console.error(`Error processing message ${index}:`, messageError);
            }
          }
          
      
        // At the end of the function, push the collected features to the parent arrays
        geojson.features.push(...topicGeojsonFeatures); // Push topic features to parent geojson array
        polygons.push(...topicPolygons); // Push topic polygons to parent polygons array
        return { topicGeojsonFeatures, topicPolygons, loadedTopicName };
      
      
        } catch (error) {
          console.error(`Error loading messages for topic ${topicId}:`, error);
          return { topicGeojsonFeatures: [], topicPolygons: [] }; // Return empty arrays on error
        }
      }

    // Array of models with their respective URLs, origins, and altitudes
    const models = [];
   
async function load3dModels() {
const customLayer = {
  id: "3d-model",
  type: "custom",
  renderingMode: "3d",
  onAdd(map, gl) {
    this.camera = new THREE.Camera();
    this.scene = new THREE.Scene();

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    this.scene.add(ambientLight);

    const directions = [
      [1, 1, 1],
      [-1, 1, 1],
      [1, -1, 1],
      [-1, -1, 1],
      [1, 1, -1],
      [-1, 1, -1],
      [1, -1, -1],
      [-1, -1, -1],
    ];

    directions.forEach((dir) => {
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
      directionalLight.position.set(...dir).normalize();
      this.scene.add(directionalLight);
    });

    this.map = map;

    this.renderer = new THREE.WebGLRenderer({
      canvas: map.getCanvas(),
      context: gl,
      antialias: true,
    });

    this.renderer.autoClear = false;
    

    const loader = new THREE.GLTFLoader(); 
    loader.setDRACOLoader(dracoLoader);


    models.forEach(({ url, origin, altitude, scaleFactorNFT }) => {
      loader.load(url, (gltf) => {
        const model = gltf.scene;
        this.scene.add(model);

        // Calculate the model's bounding box
        const box = new THREE.Box3().setFromObject(model);
        const modelSize = new THREE.Vector3();
        box.getSize(modelSize);

        // Define the desired bounding box dimensions
        const boundingBoxSize = new THREE.Vector3(10000, 10000, 10000); // Width, Height, Depth

        // Calculate the scale factor to fit the model within the bounding box
        const scaleFactor = Math.min(
          boundingBoxSize.x / modelSize.x,
          boundingBoxSize.y / modelSize.y,
          boundingBoxSize.z / modelSize.z
        );

        // Apply the scale to the model
        model.scale.set(scaleFactor*scaleFactorNFT, scaleFactor*scaleFactorNFT, scaleFactor*scaleFactorNFT);

          // Calculate the transformation matrix for each model's location and altitude
          const modelMatrix = this.map.transform.getMatrixForModel(origin, altitude);

          // Apply the transformation matrix to the model
          const modelTransformMatrix = new THREE.Matrix4()
            .fromArray(modelMatrix)
            .scale(new THREE.Vector3(10, 10, 10)); // Example scaling

          // Adjust the model's position to the bottom of the bounding box
          const modelHeight = modelSize.y * scaleFactor;
          const boundingBoxHeight = boundingBoxSize.y;
          const yOffset = (boundingBoxHeight - modelHeight) / 2;
          model.position.set(0, -yOffset, 0);

          model.applyMatrix4(modelTransformMatrix);
      });
    });
  },
  render(gl, args) {
    const mapProjectionMatrix = new THREE.Matrix4().fromArray(
      args.defaultProjectionData.mainMatrix
    );

    this.camera.projectionMatrix = mapProjectionMatrix;

    this.renderer.resetState();
    this.renderer.render(this.scene, this.camera);
    this.map.triggerRepaint();
  },
}
return customLayer;
};

map.on("style.load", async () => {
  map.setProjection({
    type: "globe",
  });

  const layers = map.getStyle().layers;
  const roadShieldLayer = layers.find(
    (layer) =>
      layer.id.toLowerCase().includes("road_shield") ||
      layer.id.toLowerCase().includes("shield")
  );

  if (roadShieldLayer) {
    map.setLayoutProperty(roadShieldLayer.id, "visibility", "none");
  }

  // Add the custom 3D model layer here
  map.addLayer(await load3dModels());
});

async function updateMapLayer() {
    // Remove the existing layer if it exists
    if (map.getLayer('3d-model')) {
        map.removeLayer('3d-model');
    }

    // Add the updated custom 3D model layer
    map.addLayer(await load3dModels());
}

let updateMapLayerIntervalId = null; // Initialize the interval ID

let updateInterval = 5000; // Default interval time in milliseconds

document.getElementById("update-loop").addEventListener("click", () => {
  const newInterval = parseInt(document.getElementById("time-input").value, 10);
  const updatesValue = document.getElementById("updates-value");
  const visibilityValue = document.getElementById("3d-model-visibility-value");
  const toggle3DModelButton = document.getElementById("toggle-3d-model-visibility");

  if (!isNaN(newInterval) && newInterval > 0) {
    updateInterval = newInterval;
    stopUpdateMapLayerLoop(); // Stop the current loop
    startUpdateMapLayerLoop(); // Start a new loop with the updated interval
    console.log(`Update interval set to ${updateInterval} milliseconds.`);
    updatesValue.textContent = "On"; // Ensure updates are "On"

    // Ensure 3D models are visible
    if (visibilityValue.textContent === "Off") {
      toggle3DModelButton.click(); // Simulate a click to turn on 3D models
    }
  } else {
    console.error("Invalid interval value. Please enter a positive number.");
  }
});

document.getElementById("toggle-updates").addEventListener("click", () => {
  const updatesValue = document.getElementById("updates-value");
  const visibilityValue = document.getElementById("3d-model-visibility-value");
  const toggle3DModelButton = document.getElementById("toggle-3d-model-visibility");

  if (updatesValue.textContent === "On") {
    stopUpdateMapLayerLoop(); // Stop the update loop
    updatesValue.textContent = "Off";
  } else {
    startUpdateMapLayerLoop(); // Start the update loop
    updatesValue.textContent = "On";

    // Ensure 3D models are visible
    if (visibilityValue.textContent === "Off") {
      toggle3DModelButton.click(); // Simulate a click to turn on 3D models
    }
  }
});

function startUpdateMapLayerLoop() {
  if (updateMapLayerIntervalId === null) { // Only start if not already running
    updateMapLayerIntervalId = setInterval(() => {
      updateMapLayer();
    }, updateInterval); // Use the updated interval time
  }
}

function stopUpdateMapLayerLoop() {
  if (updateMapLayerIntervalId !== null) {
    clearInterval(updateMapLayerIntervalId);
    updateMapLayerIntervalId = null; // Reset the interval ID
  }
}
// Call this function to start the loop
startUpdateMapLayerLoop();

document.getElementById("update-map-layer-btn").addEventListener("click", async function() {
  await updateMapLayer();
});

document.getElementById("toggle-3d-model-visibility").addEventListener("click", async function() {
    const button = this;
    const visibilityValue = document.getElementById("3d-model-visibility-value");
    const updatesValue = document.getElementById("updates-value");

    if (visibilityValue.textContent === "Off") {
        await updateMapLayer(); // Show 3D models
        startUpdateMapLayerLoop(); // Start the update loop
        visibilityValue.textContent = "On";
        button.textContent = "Hide 3D models";
        updatesValue.textContent = "On"; // Ensure updates are "On"
    } else {
        if (map.getLayer('3d-model')) {
            map.removeLayer('3d-model'); // Hide 3D models
        }
        stopUpdateMapLayerLoop(); // Stop the update loop
        visibilityValue.textContent = "Off";
        button.textContent = "Show 3D models";
        updatesValue.textContent = "Off"; // Turn updates "Off" when 3D models are hidden
    }
});


function requestPeerList() {
    if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ action: 'request_peer_list', peer_id: peerId }));
    }
}



let ws = null;
let peerId = null;
let knownPeers = new Map();
let dataChannels = new Map();
let receivedCoords = new Map();
let retryAttempts = new Map();
const maxRetries = 3;
let seenMessages = new Set();
let coordinates = null;
let heartbeatInterval = null;
let gossipInterval = null;
let peerListRequestInterval = null; // Interval for requesting peer list

async function someFunction(accountId, topicId) {
    // Clean up any existing connections
    await cleanup();

    peerId = topicId + '-' + accountId;

    connectToBootstrapServer();

    function generateMessageId() {
        return Math.random().toString(36).substr(2, 9) + '-' + Date.now();
    }

    function updateCoordinates() {
      let longitude = map.getCenter().lng; // Get current longitude from the map
      let latitude = map.getCenter().lat;   // Get current latitude from the map
      const zoomLevel = map.getZoom(); // Get the current zoom level
      let height;

      if (zoomLevel >= 10 && zoomLevel <= 19) {
          height = 50000;
      } else if (zoomLevel <= 9) {
          height = 50000 + (200000 * (10 - zoomLevel)); // Scale from 50000 at zoom 10 to 250000 at zoom 9
      } else if (zoomLevel <= 7) {
          height = 250000 + (450000 * (7 - zoomLevel)); // Scale down from 500000 to 5000000
      } else if (zoomLevel <= 3.5) {
          height = 5000000 + (65000000 * (3.5 - zoomLevel)); // Scale down from 5000000 to 70000000
      } else {
          height = 70000000; // Set height for zoom level 0
      }

        const xInput = longitude; // Set x from current longitude
        const yInput = latitude;  // Set y from current latitude
        const zInput = height;
    
        const x = parseFloat(xInput);
        const y = parseFloat(yInput);
        const z = parseFloat(zInput);
    
        // Validate input
        if (isNaN(x) || isNaN(y) || isNaN(z)) {
            console.error('Invalid coordinates: X, Y, Z must be numbers');
            alert('Please enter valid numbers for X, Y, Z');
            return;
        }
    
        coordinates = { x, y, z };
    }
        // Add this code to set up the interval for updating coordinates
        setInterval(() => {
        updateCoordinates(); // Call the function to update coordinates
    }, 5000); // 500 milliseconds interval



    function startHeartbeat() {
        setInterval(() => {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ action: 'heartbeat', peer_id: peerId }));
            }
        }, 10000); // Send every 10 seconds
    }


let globalPeers = [];

function cleanUpModels() {

    for (let i = models.length - 1; i >= 0; i--) {
        if (!globalPeers.includes(models[i].peer_id)) {
            models.splice(i, 1);
        }
    }
}


function connectToBootstrapServer() {
    ws = new WebSocket('wss://serverws-9avk.onrender.com');
    ws.onopen = () => {
        console.log('Connected to bootstrap server');
        ws.send(JSON.stringify({ action: 'register', peer_id: peerId }));
        startHeartbeat(); // Start sending heartbeats
    };

    ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);
        if (message.action === 'peer_list') {
            const peers = message.peers;
            globalPeers = peers; // Store the peers in the global array
            await setupWebRTCConnections(peers);
            startGossip();
        } else if (message.action === 'offer') {
            await handleOffer(message.peer_id, message.data);
        } else if (message.action === 'answer') {
            await handleAnswer(message.peer_id, message.data);
        } else if (message.action === 'candidate') {
            await handleCandidate(message.peer_id, message.data);
        }
    };
}

    // Add peer list request interval (every 300 seconds)
    peerListRequestInterval = setInterval(() => {
        requestPeerList();
        cleanUpModels();
    }, 300000); // Request every 300 seconds

async function setupWebRTCConnections(peerIds) {
    for (let remotePeerId of peerIds) {
        if (remotePeerId === peerId || knownPeers.has(remotePeerId)) continue;

        const pc = new RTCPeerConnection({
          iceServers: [
      {
        urls: "stun:stun.relay.metered.ca:80",
      },
      {
        urls: "turn:standard.relay.metered.ca:80",
        username: "5b426285a4417f1bf0415241",
        credential: "XNy5QEYS53JUYA5P",
      },
      {
        urls: "turn:standard.relay.metered.ca:80?transport=tcp",
        username: "5b426285a4417f1bf0415241",
        credential: "XNy5QEYS53JUYA5P",
      },
      {
        urls: "turn:standard.relay.metered.ca:443",
        username: "5b426285a4417f1bf0415241",
        credential: "XNy5QEYS53JUYA5P",
      },
      {
        urls: "turns:standard.relay.metered.ca:443?transport=tcp",
        username: "5b426285a4417f1bf0415241",
        credential: "XNy5QEYS53JUYA5P",
      },
  ],
        });
        knownPeers.set(remotePeerId, pc);
        monitorWebRTCConnection(remotePeerId, pc);

        const dc = pc.createDataChannel('gossip');
        dataChannels.set(remotePeerId, dc);
        dc.onopen = () => {
            setTimeout(() => sendGossipMessage(remotePeerId), 1000);
        };
        dc.onmessage = (event) => handleGossipMessage(remotePeerId, event.data);
        dc.onclose = () => {
            console.log(`Data channel closed with ${remotePeerId}`);
            dataChannels.delete(remotePeerId);
        };

        pc.ondatachannel = (event) => {
            const incomingDc = event.channel;
            dataChannels.set(remotePeerId, incomingDc);
            incomingDc.onmessage = (event) => handleGossipMessage(remotePeerId, event.data);
            incomingDc.onclose = () => {
                dataChannels.delete(remotePeerId);
            };
        };

        pc.onicecandidate = (event) => {
            if (event.candidate) {
                ws.send(JSON.stringify({
                    action: 'candidate',
                    peer_id: peerId,
                    target_peer_id: remotePeerId,
                    data: event.candidate
                }));
            }
        };

        try {
            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);
            ws.send(JSON.stringify({
                action: 'offer',
                peer_id: peerId,
                target_peer_id: remotePeerId,
                data: pc.localDescription
            }));
        } catch (error) {
            console.error(`Failed to create offer for ${remotePeerId}:`, error);
        }
    }
}

function sendGossipMessage(peerId) {
    const dc = dataChannels.get(peerId);
    if (dc && dc.readyState === 'open') {
        const message = { /* your message data */ };
        dc.send(JSON.stringify(message));
    } else {
        console.log(`Cannot send to ${peerId}: Data channel not open`);
    }
}

// Store pending ICE candidates
const pendingCandidates = new Map();

async function handleOffer(senderPeerId, offer) {
    if (knownPeers.has(senderPeerId)) return;

    const pc = new RTCPeerConnection({
      iceServers: [
      {
        urls: "stun:stun.relay.metered.ca:80",
      },
      {
        urls: "turn:global.relay.metered.ca:80",
        username: "5b426285a4417f1bf0415241",
        credential: "XNy5QEYS53JUYA5P",
      },
      {
        urls: "turn:global.relay.metered.ca:80?transport=tcp",
        username: "5b426285a4417f1bf0415241",
        credential: "XNy5QEYS53JUYA5P",
      },
      {
        urls: "turn:global.relay.metered.ca:443",
        username: "5b426285a4417f1bf0415241",
        credential: "XNy5QEYS53JUYA5P",
      },
      {
        urls: "turns:global.relay.metered.ca:443?transport=tcp",
        username: "5b426285a4417f1bf0415241",
        credential: "XNy5QEYS53JUYA5P",
      },
  ],
    });
    knownPeers.set(senderPeerId, pc);
    monitorWebRTCConnection(senderPeerId, pc);

    pc.onicecandidate = (event) => {
        if (event.candidate) {
            ws.send(JSON.stringify({
                action: 'candidate',
                peer_id: peerId,
                target_peer_id: senderPeerId,
                data: event.candidate
            }));
        }
    };

    pc.ondatachannel = (event) => {
        const dc = event.channel;
        dataChannels.set(senderPeerId, dc);
        dc.onmessage = (event) => handleGossipMessage(senderPeerId, event.data);
        dc.onclose = () => {
            dataChannels.delete(senderPeerId);
        };
    };

    try {
        await pc.setRemoteDescription(new RTCSessionDescription(offer));
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        ws.send(JSON.stringify({
            action: 'answer',
            peer_id: peerId,
            target_peer_id: senderPeerId,
            data: pc.localDescription
        }));

        // Process any queued ICE candidates
        if (pendingCandidates.has(senderPeerId)) {
            const candidates = pendingCandidates.get(senderPeerId);
            candidates.forEach(candidate => pc.addIceCandidate(candidate));
            pendingCandidates.delete(peerId);
        }
    } catch (error) {
        console.error(`Failed to handle offer from ${senderPeerId}:`, error);
    }
}

    async function handleAnswer(senderPeerId, answer) {
        const pc = knownPeers.get(senderPeerId);
        if (!pc) return;

        try {
            await pc.setRemoteDescription(new RTCSessionDescription(answer));
        } catch (error) {
            console.error(`Failed to handle answer from ${senderPeerId}:`, error);
        }
    }
    

    async function handleCandidate(peerId, candidate) {
    const pc = knownPeers.get(peerId);
    if (!pc) return;

    try {
        if (pc.remoteDescription && pc.remoteDescription.type) {
            await pc.addIceCandidate(new RTCIceCandidate(candidate));
        } else {
            // Queue the candidate if the remote description is not set
            if (!pendingCandidates.has(peerId)) {
                pendingCandidates.set(peerId, []);
            }
            pendingCandidates.get(peerId).push(candidate);
        }
    } catch (error) {
        console.error(`Failed to handle candidate from ${peerId}:`, error);
    }
}

function monitorWebRTCConnection(peerId, pc) {
    pc.oniceconnectionstatechange = () => {
        if (pc.iceConnectionState === 'connected') {
        } else if (pc.iceConnectionState === 'disconnected' || pc.iceConnectionState === 'failed') {
            retryWebRTCConnection(peerId);
        }
    };
}

function retryWebRTCConnection(peerId) {
    const attempts = retryAttempts.get(peerId) || 0;
    if (attempts >= maxRetries) {
        knownPeers.delete(peerId);
        dataChannels.delete(peerId);
        retryAttempts.delete(peerId);
        return;
    }

    retryAttempts.set(peerId, attempts + 1);
    knownPeers.delete(peerId);
    dataChannels.delete(peerId);
    setupWebRTCConnections([peerId]);
}

    async function handleGossipMessage(senderPeerId, data) {
        const message = JSON.parse(data);
        const { peer_id, coordinates, ttl, timestamp, messageId, metadata, scaleFactorNFT } = message;
    
        // Check for duplicates
        if (seenMessages.has(messageId)) {
            return;
        }
        seenMessages.add(messageId);
    
    
        const existing = receivedCoords.get(peer_id);
        if (!existing || new Date(timestamp) > new Date(existing.timestamp)) {
            receivedCoords.set(peer_id, { ...coordinates, timestamp });
        }

          // Load URL using the peer ID
  const url = await loadProfileObjectUrl(peer_id);

    // Check if a model from this peer_id already exists
    const modelIndex = models.findIndex(model => model.peer_id === peer_id);

    if (modelIndex !== -1) {
        // Update the existing model
        models[modelIndex] = {
            peer_id: peer_id,
            url: url || 'https://kiloscribe.com/api/inscription-cdn/0.0.8392276',
            origin: [coordinates.x, coordinates.y],
            altitude: coordinates.z,
            scaleFactorNFT: scaleFactorNFT
        };
    } else {
        // Append new message to models array
        models.push({
            peer_id: peer_id,
            url: url || 'https://kiloscribe.com/api/inscription-cdn/0.0.8392276',
            origin: [coordinates.x, coordinates.y],
            altitude: coordinates.z,
            scaleFactorNFT: scaleFactorNFT
        });
    }
        if (ttl > 0) {
            message.ttl -= 1;
            message.metadata.hopCount += 1; // Increment hop count
            forwardGossipMessage(message);
        }
    }
    function startGossip() {
        setTimeout(() => {
            setInterval(() => {
                if (knownPeers.size === 0) {
                    return;
                }
                const message = {
                    peer_id: peerId,
                    coordinates: coordinates,
                    scaleFactorNFT: finalScaleForModel,
                    ttl: 3,
                    timestamp: new Date().toISOString(),
                    messageId: generateMessageId(),
                    metadata: {
                        hopCount: 0,
                        lastUpdated: new Date().toISOString()
                    }
                };
                const fanout = Math.max(1, Math.floor(Math.sqrt(knownPeers.size))); // Dynamic fanout
                const targetPeers = Array.from(knownPeers.entries())
                    .sort(() => Math.random() - 0.5)
                    .slice(0, fanout);
                for (let [peerId, pc] of targetPeers) {
                    const dc = dataChannels.get(peerId);
                    if (dc && dc.readyState === 'open') {
                        dc.send(JSON.stringify(message));
                    } else {
                        retryWebRTCConnection(peerId);
                    }
                }
            }, 1000);
        }, 5000);
    }
    function forwardGossipMessage(message) {
        const fanout = Math.max(1, Math.floor(Math.sqrt(knownPeers.size))); // Dynamic fanout
        const targetPeers = Array.from(knownPeers.entries())
            .sort(() => Math.random() - 0.5)
            .slice(0, fanout);
        for (let [peerId, pc] of targetPeers) {
            const dc = dataChannels.get(peerId);
            if (dc && dc.readyState === 'open') {
                dc.send(JSON.stringify(message));
            } else {
                console.log(`Cannot forward to ${peerId}: Data channel not open`);
            }
        }
    }
                  async function loadProfileObjectUrl(payerId) {
                  if (!payerId) {
                  console.error("payerId is undefined");
                  return null;
                  }
                  // Remove 'peer-' prefix if present
                  const cleanPayerId = payerId.split('-')[1];
                  const topicId = "0.0.9609898";
                  const accountUrl = []; // Initialize an empty array to store account URLs
                  try {
                  const result = await window.HashinalsWalletConnectSDK.getMessages(topicId);
                  // Check if result exists and has messages
                  if (!result || !Array.isArray(result.messages) || result.messages.length === 0) {
                    console.log("No profile object found, using defaults");
                    return null; // Return null if no messages
                  }
                  // Filter messages to find those from the current user
                  const userMessages = result.messages.filter(message => message.payer === cleanPayerId);
                  // Get the last message from the filtered user messages
                  const lastMessage = userMessages[userMessages.length - 1];
                  // Check if the last message has valid data
                  if (lastMessage && lastMessage.data && lastMessage.data.urls && lastMessage.data.urls.length > 0) {
                    return lastMessage.data.urls[0]; // Return the first URL
                  }
                  return null; // Return null if no valid URL found
                  } catch (error) {
                  console.log("Error in loadProfileObject:", error);
                  return null; // Return null instead of throwing error
                  }
                  }
                    }
                    async function cleanup() {
        console.log('[Client] Cleaning up connections and state');
        if (ws && ws.readyState === WebSocket.OPEN) {
            ws.close();
            console.log('[Client] Closed WebSocket connection');
        }
        ws = null;
        if (heartbeatInterval) {
            clearInterval(heartbeatInterval);
            heartbeatInterval = null;
            console.log('[Client] Cleared heartbeat interval');
        }
        if (gossipInterval) {
            clearInterval(gossipInterval);
            gossipInterval = null;
            console.log('[Client] Cleared gossip interval');
        }
        if (peerListRequestInterval) {
            clearInterval(peerListRequestInterval);
            peerListRequestInterval = null;
            console.log('[Client] Cleared peer list request interval');
        }
        for (const [peerId, pc] of knownPeers.entries()) {
            pc.close();
            const dc = dataChannels.get(peerId);
            if (dc) {
                dc.close();
            }
            console.log(`[Client] Closed WebRTC connection with ${peerId}`);
        }
        knownPeers.clear();
        dataChannels.clear();
        receivedCoords.clear();
        retryAttempts.clear();
        seenMessages.clear();
        peerId = null;
        coordinates = null;
        models.length = 0;
        console.log('[Client] Cleared all state');
    }
    loader.updateProgress();
      }}
 </script>
  <script src="script.js"></script>
  </body>
</html>

